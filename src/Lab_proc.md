---
Хранимые процедуры: Лабораторная работа
---

[Таблица стран](assets/lab3/Страны.xlsx)

[К списку лабораторных >>>](../README.md)

---

### Задания не по таблицам

1. Напишите хранимую процедуру для вывода информации о сервере, о базе данных, о текущем пользователе, о текущем времени, и вызовите ее.
2. Напишите хранимую процедуру, принимающую число и возвращающую количество цифр в нем через параметр OUTPUT.
3. Напишите хранимую процедуру AddRightDigit, добавляющую к целому положительному числу K справа цифру D
   (D – входной параметр целого типа, лежащий в диапазоне \[0..9\], K – параметр целого типа, являющийся одновременно входным и выходным).
4. Напишите хранимую процедуру InvDigit, меняющую порядок следования цифр целого положительного числа K на обратный (K – параметр целого типа, являющийся одновременно входным и выходным).
5. Напишите хранимую процедуру Swap, меняющую содержимое переменных X и Y (X и Y – вещественные параметры, являющиеся одновременно входными и выходными).
6. Напишите хранимую процедуру SortInc, меняющую содержимое переменных A, B, C, таким образом, чтобы их значения оказались упорядоченными по возрастанию (A, B, C – вещественные параметры, являющиеся одновременно входными и выходными).
7. Напишите хранимую процедуру DigitCountSum, находящую количество C цифр целого положительного числа K, а также их сумму S (K – входной, C, S – выходные параметры целого типа).
8. Напишите код, который удаляет все хранимые процедуры, вами созданные.
    
---

### Задания по таблице стран

1. Напишите хранимую процедуру, которая выводит названия и столицы всех стран,
   средняя плотность населения которых больше средней плотности той части света, где они находятся.
2. Напишите хранимую процедуру, которая выводит данные всех стран.
3. Напишите хранимую процедуру, которая выводит список стран, кроме заданной части света, и вызовите ее.
4. Напишите хранимую процедуру, которая выводит список стран, население которых находится в заданном интервале, и вызовите ее.
5. Напишите хранимую процедуру, которая возвращает количество стран, у которых в названии отсутствует заданная буква, и вызовите ее.
6. Напишите хранимую процедуру для вывода пяти стран с наибольшим населением в заданной части света, и вызовите ее. Если часть света не указана, выбрать Африку.
7. Напишите хранимую процедуру, которая создает таблицу «Страны_<первая буква вашей фамилии>», и заполняет ее странами, названия которых начинаются с первой буквой вашей фамилии.
8. Напишите хранимую процедуру, которая удаляет таблицу, которую вы создали в предыдущем задании и возвращает количество удаленных строк.
9. Напишите код, который удаляет все хранимые процедуры, вами созданные.

---

### Хранимые процедуры

При программировании в SQL Server введенный код сначала компилируется, потом запускается.

Процесс компиляции может занимать определенное время. 
На языке Transact-SQL также есть возможность написанный блок кода сохранить и заранее скомпилировать. 
Особенно, если код многократно используется в операции базы данных, 
отличным решением будет произвести его инкапсуляцию в процедуры. 

Для этой цели используются хранимые процедуры, 
которые представляют собой набор инструкций, выполняющихся как единое целое.

Процедуры аналогичны конструкциям в других языках программирования и выполняют следующие задачи:

* обрабатывают входные параметры и возвращают значения в виде выходных параметров;
* содержат инструкции, которые выполняют операции в базе данных, в отличии от пользовательских функций;
* возвращают сведения об успешном или неуспешном завершении.

В клиент-серверной и распределенных системах хранимые процедуры 
позволяют существенно сократить сетевой трафик, поскольку по сети отправляется только вызов на выполнение процедуры.

С точки зрения безопасности, хранимые процедуры выполняют очень большую роль, 
так как устраняют необходимость предоставлять разрешения на уровне объектов и упрощают формирование уровней безопасности. 

С помощью хранимых процедур можно предотвратить атаки типа «инъекция SQL».

---

### [Создание хранимых процедур](https://metanit.com/sql/sqlserver/11.1.php)

Хранимая процедура создается с помощью команды CREATE PROCEDURE или CREATE PROC, которая имеет следующий упрощенный вид:
```sql
CREATE {PROC | PROCEDURE} <название>
[<@параметр> <тип> [= <значение по умолчанию>] [OUT | OUTPUT]]
AS
[BEGIN]
<команды>
[END]
```
При создании процедуры после команды CREATE указывается тип создаваемого объекта с помощью ключевого слова PROCEDURE или его сокращенного варианта PROC.
Названия процедур должны соответствовать требованиям, предъявляемым к идентификаторам,
и должны быть уникальными в базе данных. При этом не следует пользоваться пре-фиксом «sp_».

Этим префиксом в SQL Server обозначаются системные процедуры.

---

### [Вызов хранимых процедур](https://metanit.com/sql/sqlserver/11.1.php)

Для выполнения хранимой процедуры используется ключевое слово EXECUTE (или EXEC). 
Процедуру также можно вызывать и выполнять без ключевого слова, если она является первой инструкцией. 
Синтаксис команды EXECUTE имеет следующий вид:
```sql
EXECUTE [<@статус возврата>=] <название процедуры> [<@параметр>=] <значе-ние>| <@переменная> [OUTPUT] | [DEFAULT]
```
В отличии от вызова функций, при вызове хранимых процедур с указанием названия параметра ([<@параметр>=] <значение>), 
последовательность параметров можно не соблюдать.
Для выходных параметров при вызове указывается ключевое слово OUTPUT.
Если для параметра указано значение по умолчанию, можно его использовать с помощью ключевого слова DEFAULT.

---

### [Удаление хранимых процедур](https://metanit.com/sql/sqlserver/11.1.php)

Для удаления хранимых процедур используется команда DROP PROCEDURE. 
Упрощенный синтаксис имеет следующий вид:
```sql
DROP PROC | PROCEDURE [IF EXISTS] <название хранимой процедуры>
```
Ключевые слова IF EXISTS удаляют хранимую процедуру только в том случае, если она уже существует.

---

### [Передача входных параметров](https://metanit.com/sql/sqlserver/11.2.php)

Процедуры могут принимать параметры. 
В хранимую процедуру можно передать до 2100 параметров. 
Параметры бывают входными - с их помощью в процедуру можно передать некоторые значения,
и выходными - они позволяют возвратить из процедуры некоторое значение.

При выполнении процедуры значение каждого из объявленных параметров должно быть указано пользователем, если для параметра не определено значение по умолчанию.

Определим процедуру, которая будет добавлять данные в таблицу:
```sql
USE productsdb;
GO
CREATE PROCEDURE AddProduct
    @name NVARCHAR(20),
    @manufacturer NVARCHAR(20),
    @count INT,
    @price MONEY
AS
INSERT INTO Products(ProductName, Manufacturer, ProductCount, Price) 
VALUES(@name, @manufacturer, @count, @price)
```
После названия процедуры идет список входных параметров, 
которые определяются также как и переменные - название начинается с символа @, а после названия идет тип переменной. 

И с помощью команды INSERT значения этих параметров будут передаваться в таблицу Products.

Используем эту процедуру:
```sql
USE productsdb;
 
DECLARE @prodName NVARCHAR(20), @company NVARCHAR(20);
DECLARE @prodCount INT, @price MONEY
SET @prodName = 'Galaxy C7'
SET @company = 'Samsung'
SET @price = 22000
SET @prodCount = 5
 
EXEC AddProduct @prodName, @company, @prodCount, @price
 
SELECT * FROM Products
```

Также можно было бы передать непосредственно значения:

```sql
EXEC AddProduct 'Galaxy C7', 'Samsung', 5, 22000
```

Либо значения параметрам процедуры можно передавать по имени:

```sql
USE productsdb;
 
DECLARE @prodName NVARCHAR(20), @company NVARCHAR(20);
SET @prodName = 'Honor 9'
SET @company = 'Huawei'
 
EXEC AddProduct @name = @prodName, 
                @manufacturer=@company,
                @count = 3, 
                @price = 18000
```

При передаче параметров по имени параметру процедуры присваивается некоторое значение.

Параметры можно отмечать как необязательные, присваивая им некоторое значение по умолчанию. 
Например, в случае выше мы можем автоматически устанавливать для количества товара значение 1, 
если соответствующее значение не передано в процедуру:

```sql
USE productsdb;
GO
CREATE PROCEDURE AddProductWithOptionalCount
    @name NVARCHAR(20),
    @manufacturer NVARCHAR(20),
    @price MONEY,
    @count INT = 1
AS
INSERT INTO Products(ProductName, Manufacturer, ProductCount, Price) 
VALUES(@name, @manufacturer, @count, @price)
```
При этом необязательные параметры лучше помещать в конце списка параметров процедуры.

---

### [Передача выходных параметров](https://metanit.com/sql/sqlserver/11.3.php)

Ключевое слово OUT (можно использовать и OUTPUT) показывает, что параметр процедуры является выходным.

Например, определим еще одну процедуру:

```sql
USE productsdb;
GO
CREATE PROCEDURE GetPriceStats
    @minPrice MONEY OUTPUT,
    @maxPrice MONEY OUTPUT
AS
SELECT @minPrice = MIN(Price),  @maxPrice = MAX(Price)
FROM Products
```

При вызове процедуры для выходных параметров передаются переменные с ключевым словом OUTPUT:
```sql
USE productsdb;
DECLARE @minPrice MONEY, @maxPrice MONEY
 
EXEC GetPriceStats @minPrice OUTPUT, @maxPrice OUTPUT
 
PRINT 'Минимальная цена ' + CONVERT(VARCHAR, @minPrice)
PRINT 'Максимальная цена ' + CONVERT(VARCHAR, @maxPrice)
```

Также можно сочетать входные и выходные параметры. Например, определим процедуру, которая добавляет новую строку в таблицу и возвращает ее id:
```sql
USE productsdb;
GO
 
CREATE PROCEDURE CreateProduct
    @name NVARCHAR(20),
    @manufacturer NVARCHAR(20),
    @count INT,
    @price MONEY,
    @id INT OUTPUT
AS
    INSERT INTO Products(ProductName, Manufacturer, ProductCount, Price)
    VALUES(@name, @manufacturer, @count, @price)
    SET @id = @@IDENTITY
```

С помощью глобальной переменной @@IDENTITY можно получить идентификатор добавленной записи.

При вызове этой процедуры ей также по позиции передаются все входные и выходные параметры:

```sql
USE productsdb;
 
DECLARE @id INT
 
EXEC CreateProduct 'LG V30', 'LG', 3, 28000, @id OUTPUT
 
PRINT @id
```

Кроме передачи результата выполнения через выходные параметры хранимая процедура 
также может возвращать какое-либо значение типа INT с помощью оператора RETURN. 

Хотя данная возможность во многом нивелирована использованием выходных параметров, 
через которые можно возвращать результат, тем не менее, если надо возвратить из процедуры одно значение,
то вполне можно использовать оператор RETURN.

Например, возвратим среднюю цену на товары:
```sql
USE productsdb;
GO
CREATE PROCEDURE GetAvgPrice AS
DECLARE @avgPrice MONEY
SELECT @avgPrice = AVG(Price)
FROM Products
RETURN @avgPrice;
```

После оператора RETURN указывается возвращаемое значение. В данном случае это значение переменной @avgPrice.

Вызовем данную процедуру:

```sql
USE productsdb;
 
DECLARE @result MONEY
 
EXEC @result = GetAvgPrice
PRINT @result
```

Для получения результата процедуры ее значение сохраняется в переменную (в данном случае в переменную @result)

Стоит отметить, что RETURN возвращает только целочисленные значения.

---
