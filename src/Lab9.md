---
title: Лабораторная работа 9. Хранимые процедуры и триггеры
---

[Таблица стран](assets/lab3/Страны.xlsx)

[Таблица учеников](assets/lab5/Pupils.xlsx)

[Вариант 2](assets/lab/v2.md)

[К списку лабораторных >>>](../README.md)

---

### Задания не по таблицам

1. Напишите хранимую процедуру для вывода информации о сервере, о базе данных, о текущем пользователе, о текущем времени, и вызовите ее.
2. Напишите хранимую процедуру, принимающую число и возвращающую количество цифр в нем через параметр OUTPUT.
3. Напишите хранимую процедуру AddRightDigit, добавляющую к целому положительному числу K справа цифру D
   (D – входной параметр целого типа, лежащий в диапазоне \[0..9\], K – параметр целого типа, являющийся одновременно входным и выходным).
4. Напишите хранимую процедуру InvDigit, меняющую порядок следования цифр целого положительного числа K на обратный (K – параметр целого типа, являющийся одновременно входным и выходным).
5. Напишите хранимую процедуру Swap, меняющую содержимое переменных X и Y (X и Y – вещественные параметры, являющиеся одновременно входными и выходными).
6. Напишите хранимую процедуру SortInc, меняющую содержимое переменных A, B, C, таким образом, чтобы их значения оказались упорядоченными по возрастанию (A, B, C – вещественные параметры, являющиеся одновременно входными и выходными).
7. Напишите хранимую процедуру DigitCountSum, находящую количество C цифр целого положительного числа K, а также их сумму S (K – входной, C, S – выходные параметры целого типа).
8. Напишите код, который удаляет все хранимые процедуры, вами созданные.
    
---

### Задания по таблице стран

1. Напишите хранимую процедуру, которая выводит названия и столицы всех стран,
   средняя плотность населения которых больше средней плотности той части света, где они находятся.
2. Напишите хранимую процедуру, которая выводит данные всех стран.
3. Напишите хранимую процедуру, которая выводит список стран, кроме заданной части света, и вызовите ее.
4. Напишите хранимую процедуру, которая выводит список стран, население которых находится в заданном интервале, и вызовите ее.
5. Напишите хранимую процедуру, которая возвращает количество стран, у которых в названии отсутствует заданная буква, и вызовите ее.
6. Напишите хранимую процедуру для вывода пяти стран с наибольшим населением в заданной части света, и вызовите ее. Если часть света не указана, выбрать Африку.
7. Напишите хранимую процедуру, которая создает таблицу «Страны_<первая буква вашей фамилии>», и заполняет ее странами, названия которых начинаются с первой буквой вашей фамилии.
8. Напишите хранимую процедуру, которая удаляет таблицу, которую вы создали в предыдущем задании и возвращает количество удаленных строк.
9. Напишите код, который удаляет все хранимые процедуры, вами созданные.

---

### Задание по таблице учеников

1. Напишите триггер на изменение записи в таблице «Ученики». Данный триггер, в случае изменения данных, должен вывести «Запись изменена».
2. Напишите триггер на добавление и удаление записи из таблицы «Ученики». Данный триггер, в случае успешного добавления или удаления данных, должен вывести «Количество строк изменено: {количество измененных/затронутых строк}».
3. Напишите триггер на добавление, изменение и удаление данных в таблице «Ученики». Данный триггер должен вывести «{Текущий пользователь} изменил таблицу. Время: {текущее время}».
4. Напишите триггер на изменение записи в таблице «Ученики». Данный триггер, при попытке изменения данных, должен вывести «Нельзя редактировать данные».
5. Создать таблицу «Ученики_{Ваша_фамилия}», которая будет содержать фамилии удаленных учеников и даты их удаления. Написать триггер, который будет фиксировать в таблице «Ученики_{Ваша_фамилия}» данные учеников при удалении из таблицы «Ученики», в том случае, если у них остались однофамильцы в таблице «Ученики».
6. Напишите команды для приостановления и запуска триггера из предыдущей задачи.
7. Напишите команды для удаления всех созданных вами триггеров.

---

### Задание по таблицам из демо-экзамена

Разработать и написать процедуры и триггеры, необходимые для правильной работы приложения
[Вариант 2](assets/lab/v2.md)

---

### Хранимые процедуры

При программировании в SQL Server введенный код сначала компилируется, потом запускается.

Процесс компиляции может занимать определенное время. 
На языке Transact-SQL также есть возможность написанный блок кода сохранить и заранее скомпилировать. 
Особенно, если код многократно используется в операции базы данных, 
отличным решением будет произвести его инкапсуляцию в процедуры. 

Для этой цели используются хранимые процедуры, 
которые представляют собой набор инструкций, выполняющихся как единое целое.

Процедуры аналогичны конструкциям в других языках программирования и выполняют следующие задачи:

* обрабатывают входные параметры и возвращают значения в виде выходных параметров;
* содержат инструкции, которые выполняют операции в базе данных, в отличии от пользовательских функций;
* возвращают сведения об успешном или неуспешном завершении.

В клиент-серверной и распределенных системах хранимые процедуры 
позволяют существенно сократить сетевой трафик, поскольку по сети отправляется только вызов на выполнение процедуры.

С точки зрения безопасности, хранимые процедуры выполняют очень большую роль, 
так как устраняют необходимость предоставлять разрешения на уровне объектов и упрощают формирование уровней безопасности. 

С помощью хранимых процедур можно предотвратить атаки типа «инъекция SQL».

---

### [Создание хранимых процедур](https://metanit.com/sql/sqlserver/11.1.php)

Хранимая процедура создается с помощью команды CREATE PROCEDURE или CREATE PROC, которая имеет следующий упрощенный вид:
```sql
CREATE {PROC | PROCEDURE} <название>
[<@параметр> <тип> [= <значение по умолчанию>] [OUT | OUTPUT]]
AS
[BEGIN]
<команды>
[END]
```
При создании процедуры после команды CREATE указывается тип создаваемого объекта с помощью ключевого слова PROCEDURE или его сокращенного варианта PROC.
Названия процедур должны соответствовать требованиям, предъявляемым к идентификаторам,
и должны быть уникальными в базе данных. При этом не следует пользоваться пре-фиксом «sp_».

Этим префиксом в SQL Server обозначаются системные процедуры.

---

### [Вызов хранимых процедур](https://metanit.com/sql/sqlserver/11.1.php)

Для выполнения хранимой процедуры используется ключевое слово EXECUTE (или EXEC). 
Процедуру также можно вызывать и выполнять без ключевого слова, если она является первой инструкцией. 
Синтаксис команды EXECUTE имеет следующий вид:
```sql
EXECUTE [<@статус возврата>=] <название процедуры> [<@параметр>=] <значе-ние>| <@переменная> [OUTPUT] | [DEFAULT]
```
В отличии от вызова функций, при вызове хранимых процедур с указанием названия параметра ([<@параметр>=] <значение>), 
последовательность параметров можно не соблюдать.
Для выходных параметров при вызове указывается ключевое слово OUTPUT.
Если для параметра указано значение по умолчанию, можно его использовать с помощью ключевого слова DEFAULT.

---

### [Удаление хранимых процедур](https://metanit.com/sql/sqlserver/11.1.php)

Для удаления хранимых процедур используется команда DROP PROCEDURE. 
Упрощенный синтаксис имеет следующий вид:
```sql
DROP PROC | PROCEDURE [IF EXISTS] <название хранимой процедуры>
```
Ключевые слова IF EXISTS удаляют хранимую процедуру только в том случае, если она уже существует.

---

### [Передача входных параметров](https://metanit.com/sql/sqlserver/11.2.php)

Процедуры могут принимать параметры. 
В хранимую процедуру можно передать до 2100 параметров. 
Параметры бывают входными - с их помощью в процедуру можно передать некоторые значения,
и выходными - они позволяют возвратить из процедуры некоторое значение.

При выполнении процедуры значение каждого из объявленных параметров должно быть указано пользователем, если для параметра не определено значение по умолчанию.

Определим процедуру, которая будет добавлять данные в таблицу:
```sql
USE productsdb;
GO
CREATE PROCEDURE AddProduct
    @name NVARCHAR(20),
    @manufacturer NVARCHAR(20),
    @count INT,
    @price MONEY
AS
INSERT INTO Products(ProductName, Manufacturer, ProductCount, Price) 
VALUES(@name, @manufacturer, @count, @price)
```
После названия процедуры идет список входных параметров, 
которые определяются также как и переменные - название начинается с символа @, а после названия идет тип переменной. 

И с помощью команды INSERT значения этих параметров будут передаваться в таблицу Products.

Используем эту процедуру:
```sql
USE productsdb;
 
DECLARE @prodName NVARCHAR(20), @company NVARCHAR(20);
DECLARE @prodCount INT, @price MONEY
SET @prodName = 'Galaxy C7'
SET @company = 'Samsung'
SET @price = 22000
SET @prodCount = 5
 
EXEC AddProduct @prodName, @company, @prodCount, @price
 
SELECT * FROM Products
```

Также можно было бы передать непосредственно значения:

```sql
EXEC AddProduct 'Galaxy C7', 'Samsung', 5, 22000
```

Либо значения параметрам процедуры можно передавать по имени:

```sql
USE productsdb;
 
DECLARE @prodName NVARCHAR(20), @company NVARCHAR(20);
SET @prodName = 'Honor 9'
SET @company = 'Huawei'
 
EXEC AddProduct @name = @prodName, 
                @manufacturer=@company,
                @count = 3, 
                @price = 18000
```

При передаче параметров по имени параметру процедуры присваивается некоторое значение.

Параметры можно отмечать как необязательные, присваивая им некоторое значение по умолчанию. 
Например, в случае выше мы можем автоматически устанавливать для количества товара значение 1, 
если соответствующее значение не передано в процедуру:

```sql
USE productsdb;
GO
CREATE PROCEDURE AddProductWithOptionalCount
    @name NVARCHAR(20),
    @manufacturer NVARCHAR(20),
    @price MONEY,
    @count INT = 1
AS
INSERT INTO Products(ProductName, Manufacturer, ProductCount, Price) 
VALUES(@name, @manufacturer, @count, @price)
```
При этом необязательные параметры лучше помещать в конце списка параметров процедуры.

---

### [Передача выходных параметров](https://metanit.com/sql/sqlserver/11.3.php)

Ключевое слово OUT (можно использовать и OUTPUT) показывает, что параметр процедуры является выходным.

Например, определим еще одну процедуру:

```sql
USE productsdb;
GO
CREATE PROCEDURE GetPriceStats
    @minPrice MONEY OUTPUT,
    @maxPrice MONEY OUTPUT
AS
SELECT @minPrice = MIN(Price),  @maxPrice = MAX(Price)
FROM Products
```

При вызове процедуры для выходных параметров передаются переменные с ключевым словом OUTPUT:
```sql
USE productsdb;
DECLARE @minPrice MONEY, @maxPrice MONEY
 
EXEC GetPriceStats @minPrice OUTPUT, @maxPrice OUTPUT
 
PRINT 'Минимальная цена ' + CONVERT(VARCHAR, @minPrice)
PRINT 'Максимальная цена ' + CONVERT(VARCHAR, @maxPrice)
```

Также можно сочетать входные и выходные параметры. Например, определим процедуру, которая добавляет новую строку в таблицу и возвращает ее id:
```sql
USE productsdb;
GO
 
CREATE PROCEDURE CreateProduct
    @name NVARCHAR(20),
    @manufacturer NVARCHAR(20),
    @count INT,
    @price MONEY,
    @id INT OUTPUT
AS
    INSERT INTO Products(ProductName, Manufacturer, ProductCount, Price)
    VALUES(@name, @manufacturer, @count, @price)
    SET @id = @@IDENTITY
```

С помощью глобальной переменной @@IDENTITY можно получить идентификатор добавленной записи.

При вызове этой процедуры ей также по позиции передаются все входные и выходные параметры:

```sql
USE productsdb;
 
DECLARE @id INT
 
EXEC CreateProduct 'LG V30', 'LG', 3, 28000, @id OUTPUT
 
PRINT @id
```

Кроме передачи результата выполнения через выходные параметры хранимая процедура 
также может возвращать какое-либо значение типа INT с помощью оператора RETURN. 

Хотя данная возможность во многом нивелирована использованием выходных параметров, 
через которые можно возвращать результат, тем не менее, если надо возвратить из процедуры одно значение,
то вполне можно использовать оператор RETURN.

Например, возвратим среднюю цену на товары:
```sql
USE productsdb;
GO
CREATE PROCEDURE GetAvgPrice AS
DECLARE @avgPrice MONEY
SELECT @avgPrice = AVG(Price)
FROM Products
RETURN @avgPrice;
```

После оператора RETURN указывается возвращаемое значение. В данном случае это значение переменной @avgPrice.

Вызовем данную процедуру:

```sql
USE productsdb;
 
DECLARE @result MONEY
 
EXEC @result = GetAvgPrice
PRINT @result
```

Для получения результата процедуры ее значение сохраняется в переменную (в данном случае в переменную @result)

Стоит отметить, что RETURN возвращает только целочисленные значения.

---

### Триггеры

Триггер – это вид хранимой процедуры, который вызывается автоматически при опре-деленных событиях. Часто триггеры применяются для автоматической поддержки целостно-сти и защиты БД.
В MS SQL Server существует три вида триггеров, которые отличаются по функциям и по синтаксису создания и изменения: Триггеры DML вызываются при выполнении команд INSERT, UPDATE или DELETE. Можно создать триггер, реагирующий на две или на все три команды. Триггеры DDL реагируют на события изменения структуры БД: создание, изменение или удаление отдельных объектов БД. Триггеры входа в систему запускаются при соединении пользователя с экземпляром сервера. Их можно применять для дополнительной проверки полномочий пользователей.
Триггеры DML можно вызвать после событий (FOR | AFTER), или вместо него (INSTEAD OF).
Триггер AFTER выполняется после успешного завершения вызвавшего его события. Можно определить несколько АFТЕR-триггеров для каждой операции.
Триггер INSTEAD OF вызывается вместо выполнения команд. Для каждой операции INSERT, UPDATE, DELETE можно определить только один INSTEAD ОF-триггер.

---

### [Создание триггеров](https://metanit.com/sql/sqlserver/12.1.php)

Упрощенный синтаксис создания триггера имеет следующий вид:
```sql
CREATE TRIGGER <название триггера> ON <название таблицы>
<FOR | AFTER | INSTEAD OF> <INSERT | UPDATE | DELETE>
AS
[BEGIN]
<команды>
[END]
```
---

### Приостановление триггеров

Если при определенных обстоятельствах выполнение триггера нежелательно, то можно его отключить. Для этого используется команда DISABLE TRIGGER, его синтаксис:
```sql
DISABLE TRIGGER <название триггера> ON <название таблицы>
```
А когда триггер снова понадобится, его можно включить с помощью команды ENABLE TRIGGER, его синтаксис:
```sql
ENABLE TRIGGER <название триггера> ON <название таблицы>
```

---

### Удаление триггеров

Для удаления триггера используется команда DROP TRIGGER, его синтаксис:
```sql
DROP TRIGGER <название триггера>
```

---

### [Триггеры после событий](https://metanit.com/sql/sqlserver/12.2.php)

Ключевое слово FOR или AFTER указывает, что триггер DML срабатывает только 
после успешного запуска всех операций в инструкции SQL, по которой срабатывает триггер.

В определении триггера ключевые слова INSERT | UPDATE | DELETE определяют инструкции изменения данных, 
при применении которых к таблице или представлению срабатывает триггер DML. 
Указание хотя бы одного варианта обязательно. 

В определении триггера после событий разрешены любые сочетания вариантов в любом порядке.

Триггеры не вызываются рекурсивно.

Хотя инструкция TRUNCATE TABLE по сути аналогичная инструкции DELETE, она не активирует триггер.

#### Добавление

При добавлении данных (при выполнении команды INSERT) в триггере мы можем получить добавленные данные из виртуальной таблицы INSERTED.

Определим триггер, который будет срабатывать после добавления:

```sql
USE productsdb
GO
CREATE TRIGGER Products_INSERT
ON Products
AFTER INSERT
AS
INSERT INTO History (ProductId, Operation)
SELECT Id, 'Добавлен товар ' + ProductName + '   фирма ' + Manufacturer
FROM INSERTED
```

Этот триггер будет добавлять в таблицу History данные о добавлении товара, которые берутся из виртуальной таблицы INSERTED.

#### Удаление данных

При удалении все удаленные данные помещаются в виртуальную таблицу DELETED:

```sql
USE productsdb
GO
CREATE TRIGGER Products_DELETE
ON Products
AFTER DELETE
AS
INSERT INTO History (ProductId, Operation)
SELECT Id, 'Удален товар ' + ProductName + '   фирма ' + Manufacturer
FROM DELETED
```

Здесь, как и в случае с предыдущим триггером, помещаем информацию об удаленных товарах в таблицу History.

#### Изменение данных

Триггер обновления данных срабатывает при выполнении операции UPDATE. И в таком триггере мы можем использовать две виртуальных таблицы. Таблица INSERTED хранит значения строк после обновления, а таблица DELETED хранит те же строки, но до обновления.

Создадим триггер обновления:

```sql
USE productsdb
GO
CREATE TRIGGER Products_UPDATE
ON Products
AFTER UPDATE
AS
INSERT INTO History (ProductId, Operation)
SELECT Id, 'Обновлен товар ' + ProductName + '   фирма ' + Manufacturer
FROM INSERTED
```

И при обновлении данных сработает данный триггер.

---

### [Триггеры вместо событий](https://metanit.com/sql/sqlserver/12.3.php)

Ключевое слово INSTEAD OF указывает, что триггер DML выполняется вместо инструкции SQL, 
по которой он срабатывает, то есть переопределяет действия запускающих инструкций.

Он определяется также, как триггер AFTER, за тем исключением, 
что он может определяться только для одной операции - INSERT, DELETE или UPDATE.

И также он может применяться как для таблиц, так и для представлений (триггер AFTER применяется только для таблиц).

Определим триггер для удаления записи:

```sql
USE prods
GO
CREATE TRIGGER products_delete
ON Products
INSTEAD OF DELETE
AS
UPDATE Products
SET IsDeleted = 1
WHERE ID =(SELECT Id FROM deleted)
```

Добавим некоторые данные в таблицу и выполним удаление из нее:

```sql
USE prods;
 
INSERT INTO Products(ProductName, Manufacturer, Price)
VALUES ('iPhone X', 'Apple', 79000),
('Pixel 2', 'Google', 60000);
 
DELETE FROM Products 
WHERE ProductName='Pixel 2';
 
SELECT * FROM Products;
```

Таким образом, удаляемые записи на самом деле не будут удаляться, просто у них будет устанавливаться значение для столбца IsDeleted.

---

### Виртуальные таблицы в триггерах

Если триггер выполняется для события добавления данных (команды INSERT), 
в теле триггера доступна виртуальная таблица INSERTED, которая содержит список добавленных данных.
Если триггер выполняется для события удаления данных (команды DELETE),
в теле триггера доступна виртуальная таблица DELETED, которая содержит список удаленных данных.
Если триггер выполняется для события изменения данных (команды UPDATE), 
в теле триггера доступны две виртуальные таблицы INSERTED и DELETED, которые содержат список новых и старых данных, соответственно.

---
