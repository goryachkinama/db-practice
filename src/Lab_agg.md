---
title: Лабораторная работа 5. Агрегатные функции и группировка
---

[Таблица стран](assets/lab3/Страны.xlsx)

[Таблица учеников](assets/lab5/Students.xlsx)

[К списку лабораторных >>>](../README.md)

---

### Задание по таблице стран

1. Вывести минимальную площадь стран.
2. Вывести наибольшую по населению страну в Северной и Южной Америке.
3. Вывести среднее население стран. Результат округлить до одного знака.
4. Вывести количество стран, у которых название заканчивается на «ан», кроме стран, у которых название заканчивается на «стан».
5. Вывести количество континентов, где есть страны, название которых начинается с буквы «Р».
6. Во сколько раз страна с наибольшей площадью больше, чем страна с наименьшей площадью?
7. Вывести количество стран с населением больше, чем 100 млн. чел. на каждом континенте.
   Результат отсортировать по количеству стран по возрастанию.
9. Вывести количество стран по количеству букв в названии. Результат отсортировать по убыванию.
10. Ожидается, что через 20 лет население мира вырастет на 10%. Вывести список континентов с прогнозируемым населением:
11. Вывести список континентов, где наибольшие и наименьшие площади стран различаются не более, чем в 10000 раз.
12. Вывести среднюю длину названий Африканских стран.
13. Вывести список континентов, у которых средняя плотность среди стран с населением более 1 млн. чел. больше, чем 30 чел. на кв. км.

---

### [Агрегатные функции](https://metanit.com/sql/sqlserver/5.1.php)

Агрегатные функции используются для получения обобщающих значений. 
Они, в отличие от скалярных функций, оперируют значениями столбцов множества строк.

К агрегатным функциям относятся:
* SUM – вычисляет итог;
* MAX – возвращает наибольшее значение;
* MIN – возвращает наименьшее значение;
* AVG – вычисляет среднее значение;
* COUNT – вычисляет количество значений в столбце;
* STRING_AGG - сцепляет значения строковых выражений, помещая между ними значения-разделители.

Аргументами функций выступают поля таблицы или результаты выражений над ними.
Вложенность не допускается.

Из агрегатных функций можно составлять любые выражения.

Для функций SUM и AVG столбец должен содержать числовые значения.
Выражение в функциях MIN, MAX и COUNT может представлять числовое или строковое значение или дату.

Для функций COUNT() можно указать аргумент * для подсчета всех строк без исключения.

Все агрегатные функции за исключением COUNT(*) игнорируют значения NULL.

---

### AVG

Функция Avg возвращает среднее значение на диапазоне значений столбца таблицы.

Пример. Найдем среднюю цену товаров из базы данных:

```sql
SELECT AVG(Price) AS Average_Price FROM Products
```

Также мы можем применить фильтрацию.
Пример. Найти среднюю цену для товаров какого-то определенного производителя:

```sql
SELECT AVG(Price) FROM Products
WHERE Manufacturer='Apple'
```

---

### COUNT
Функция Count вычисляет количество строк в выборке. Есть две формы этой функции. Первая форма COUNT(*) подсчитывает число строк в выборке:

```sql
SELECT COUNT(*) FROM Products
```

Вторая форма функции вычисляет количество строк по определенному столбцу, при этом строки со значениями NULL игнорируются:

```sql
SELECT COUNT(Manufacturer) FROM Products
```

---

### MIN и MAX

Функции Min и Max возвращают соответственно минимальное и максимальное значение по столбцу. Например, найдем минимальную цену среди товаров:

```sql
SELECT MIN(Price) FROM Products
```

Поиск максимальной цены:

```sql
SELECT MAX(Price) FROM Products
```

Данные функции также игнорируют значения NULL и не учитывают их при подсчете.

---

### SUM

Функция Sum вычисляет сумму значений столбца. Например, подсчитаем общее количество товаров:

```sql
SELECT SUM(ProductCount) FROM Products
```

Также вместо имени столбца может передаваться вычисляемое выражение. Например, найдем общую стоимость всех имеющихся товаров:

```sql
SELECT SUM(ProductCount * Price) FROM Products
```

### STRING_AGG

Функция STRING_AGG сцепляет значения строковых выражений, помещая между ними значения-разделители. 
В конце строки разделитель не добавляется.

Синтаксис:
```sql
STRING_AGG ( expression, separator ) [ <order_clause> ]

<order_clause> ::=   
    WITHIN GROUP ( ORDER BY <order_by_expression_list> [ ASC | DESC ] )
```

expression (выражение):
Выражение любого типа данных. Во время объединения выражения преобразуются в тип NVARCHAR или VARCHAR. Нестроковые типы преобразуются в тип NVARCHAR.

separator (разделитель):
Выражение типа NVARCHAR или VARCHAR, которое используется в качестве разделителя сцепляемых строк. Может быть литералом или переменной.

<order_clause>
При необходимости укажите очередность сцепляемых результатов с помощью предложения WITHIN GROUP:

```sql
WITHIN GROUP ( ORDER BY <order_by_expression_list> [ ASC | DESC ] )
```

<order_by_expression_list>
Список неконстантных выражений, который можно использовать для сортировки результатов. 
В запросе допускается только один аргумент order_by_expression. По умолчанию задан порядок сортировки по возрастанию.

Пример:
```sql
USE AdventureWorks2022;
GO
SELECT STRING_AGG (CONVERT(NVARCHAR(max),FirstName), CHAR(13)) AS csv 
FROM Person.Person;
GO
```

---

### ALL и DISTINCT

По умолчанию вышеперечисленные пять функций учитывают все строки выборки для вычисления результата.

Но выборка может содержать повторяющиеся значения. Если необходимо выполнить вычисления только над уникальными значениями, 
исключив из набора значений повторяющиеся данные, то для этого применяется оператор DISTINCT (кроме COUNT(*)). 

```sql
SELECT AVG(DISTINCT ProductCount) AS Average_Price FROM Products
```

По умолчанию вместо DISTINCT применяется оператор ALL, который выбирает все строки. 

```sql
SELECT AVG(ALL ProductCount) AS Average_Price FROM Products
```

Так как этот оператор неявно подразумевается при отсутствии DISTINCT, то его можно не указывать.

### Комбинирование функций

Пример. Объединим применение нескольких функций:

```sql
SELECT COUNT(*) AS ProdCount,
       SUM(ProductCount) AS TotalCount,
       MIN(Price) AS MinPrice,
       MAX(Price) AS MaxPrice,
       AVG(Price) AS AvgPrice
FROM Products
```

---

### [Оператор GROUP BY](https://metanit.com/sql/sqlserver/5.2.php) 

Агрегатные функции можно применить не только на всю таблицу, но также на группу значений. 
Для этого применяется команда GROUP BY, которая пишется после WHERE.

После команды GROUP BY перечисляется название столбцов, по которым следует группировать данные. 

Предложение GROUP BY указывает, что результаты запроса следует разделить на группы, 
применить агрегатную функцию по отдельности к каждой группе и получить для каждой группы одну строку результатов.

В качестве элемента группировки должен выступать любой возвращаемый элемент, указанный в предложении SELECT, кроме значений агрегатных функций.

Например, сгруппируем товары по производителю

```sql
SELECT Manufacturer, COUNT(*) AS ModelsCount
FROM Products
GROUP BY Manufacturer
```

Первый столбец в выражении SELECT - Manufacturer представляет название группы, 
а второй столбец - ModelsCount представляет результат функции Count, которая вычисляет количество строк в группе.

Стоит учитывать, что любой столбец, который используется в выражении SELECT (не считая столбцов, которые хранят результат агрегатных функций), должны быть указаны после оператора GROUP BY. Так, например, в случае выше столбец Manufacturer указан и в выражении SELECT, и в выражении GROUP BY.

И если в выражении SELECT производится выборка по одному или нескольким столбцам и также используются агрегатные функции, то необходимо использовать выражение GROUP BY. Так, следующий пример работать не будет, так как он не содержит выражение группировки:

```sql
SELECT Manufacturer, COUNT(*) AS ModelsCount
FROM Products
```

Другой пример, добавим группировку по количеству товаров:

```sql
SELECT Manufacturer, ProductCount, COUNT(*) AS ModelsCount
FROM Products
GROUP BY Manufacturer, ProductCount
```

Оператор GROUP BY может выполнять группировку по множеству столбцов.

Если столбец, по которому производится группировка, содержит значение NULL, то строки со значением NULL составят отдельную группу.

Следует учитывать, что выражение GROUP BY должно идти после выражения WHERE, но до выражения ORDER BY:

```sql
SELECT Manufacturer, COUNT(*) AS ModelsCount
FROM Products
WHERE Price > 30000
GROUP BY Manufacturer
ORDER BY ModelsCount DESC
```

---

### HAVING

Команда HAVING <условие> применяется для фильтрации строк, возвращаемых при использовании предложения GROUP BY. 

HAVING пишется после GROUP BY, имеет такой формат, как WHERE, но в качестве значения используется значение, возвращаемое агрегатными функциями.

Применение HAVING во многом аналогично применению WHERE. Только если WHERE применяется к фильтрации строк, то HAVING используется для фильтрации групп.

Например, найдем все группы товаров по производителям, для которых определено более 1 модели:

```sql
SELECT Manufacturer, COUNT(*) AS ModelsCount
FROM Products
GROUP BY Manufacturer
HAVING COUNT(*) > 1
```

При этом в одной команде мы можем использовать выражения WHERE и HAVING:

```sql
SELECT Manufacturer, COUNT(*) AS ModelsCount
FROM Products
WHERE Price * ProductCount > 80000
GROUP BY Manufacturer
HAVING COUNT(*) > 1
```

То есть в данном случае сначала фильтруются строки: выбираются те товары, общая стоимость которых больше 80000. 
Затем выбранные товары группируются по производителям. И далее фильтруются сами группы - выбираются те группы, которые содержат больше 1 модели.

Если при этом необходимо провести сортировку, то выражение ORDER BY идет после выражения HAVING.

---
