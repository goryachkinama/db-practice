---
Представления. Табличные объекты: Лабораторная работа
---

[Таблица стран](assets/lab3/Страны.xlsx)

[Таблицы студентов](assets/lab6/Students.xlsx)

[Вариант 2](assets/lab/v2.md)

[К списку лабораторных >>>](../README.md)

---

### Часть 1. Задания по таблицам студентов

1. Создайте представление, содержащее фамилии преподавателей, их должность, звание, степень, место работы, количество их экзаменов, и используйте его.
2. С помощью обобщенных табличных выражений напишите запрос для вывода списка сотрудников, чьи зарплаты меньше, чем средняя зарплата по факультету, их зарплаты и название факультета.
3. Создайте локальную временную таблицу, имеющую три столбца («Номер недели», «Количество экзаменов», «Количество студентов»), заполните и используйте ее.
4. Напишите команды для удаления всех созданных вами представлений.

---

### Часть 2. Задание по таблице стран

1. Создайте представление, содержащее список африканских стран, население которых больше 10 млн. чел., а площадь больше 500 тыс. кв. км, и используйте его.
2. Создайте представление, содержащее список континентов, среднюю площадь стран, которые находятся на нем, среднюю плотность населения, и используйте его.
3. Создайте табличную переменную, содержащую список стран, площадь которых в 100 раз меньше, чем средняя площадь стран на континенте, где они находятся, и используйте ее.
4. Создайте глобальную временную таблицу, содержащую название континентов, наибольшую и наименьшую площадь стран на них, заполните и используйте ее.
5. Создайте глобальную временную таблицу, содержащую название стран и плотность их населения, заполните и используйте ее.
6. Напишите команды для удаления всех созданных вами представлений.

---

### Часть 5. Задание по таблицам из демо-экзамена

На основе разработанных таблиц реализовать представления, необходимые для правильной работы приложения (фильтрация, сортировка, постраничный вывод и пр)
[Вариант 2](assets/lab/v2.md)

---

### [Представления](https://metanit.com/sql/sqlserver/10.1.php)

Представление – это виртуальная таблица, содержимое которой определяется запросом. 
Как и таблица, представление состоит из ряда именованных столбцов и строк данных.

Представления, как таблицы, могут иметь до 1024 столбцов.
Запрос для создания представления может обращаться не более чем к 256 таблицам.

Можно создавать представления на основе других представлений, при этом уровень
вложенности не может быть больше 32-х.

Представление можно использовать как обычную таблицу.
Упрощенный синтаксис создания преставления имеет следующий вид:
```sql
CREATE VIEW <название> <список столбцов>
AS <запрос SELECT>
```
Запрос SELECT, используемый в определении представления, не может включать предложение ORDER BY, 
если только в списке выбора инструкции SELECT нет также предложения TOP.

Для удаления представления используется команда DROP VIEW, его синтаксис:
```sql
DROP VIEW <название>
```
---

### [Обновляемое представление](https://metanit.com/sql/sqlserver/10.2.php)

Представления могут быть обновляемыми (updatable). В таких представлениях мы можем изменить или удалить строки или добавить в них новые строки.

При создании подобных представлений есть множество ограничений. В частности, команда SELECT при создании обновляемого представления не может содержать:

* TOP
* DISTINCT
* UNION
* JOIN
* агрегатные функции типа COUNT или MAX
* GROUP BY и HAVING
* подзапросы
* производные столбцы или столбцы, которые вычисляются на основании нескольких значений
* обращения одновременно к нескольким таблицам

Стоит отметить, что это касается именно обновляемого представления. 

Например, для создания обычного представления мы можем использовать в команде SELECT оператор JOIN, 
однако такое представление не будет обновляемым. 
При попытке его обновить, мы будем получать ошибку вида 
"View or function название_представления is not updatable because the modification affects multiple base tables."

### [Обновление данных с помощью представления](https://professorweb.ru/my/sql-server/2012/level3/3_7.php)

Инструкцию UPDATE можно применять с представлением, как будто бы это была базовая таблица. При модифицировании строк представления также модифицируется содержимое таблицы в его основе. Запрос в примере создает представление, посредством которого затем модифицируется таблица Works_on:

```sql
USE SampleDb;

GO
CREATE VIEW view_p1
    AS SELECT EmpId, Job
    FROM Works_on
    WHERE ProjectNumber = 'p1';

GO
UPDATE view_p1
    SET Job = NULL
    WHERE Job = 'Менеджер';
```

Операцию обновления представления view_p1 в примере выше можно рассматривать 
эквивалентной выполнению следующей инструкции UPDATE:

```sql
UPDATE Works_on
    SET Job = NULL
    WHERE Job = 'Менеджер'
        AND ProjectNumber = 'p1';
```

Логическое значение предложения WITH CHECK OPTION для инструкции UPDATE имеет такое же значение,
как и для инструкции INSERT. Использование предложения WITH CHECK OPTION в инструкции UPDATE показано в примере ниже:

```sql
USE SampleDb;

GO
CREATE VIEW view_100000
    AS SELECT Number, Budget
    FROM Project
    WHERE Budget > 100000
    WITH CHECK OPTION;

GO
UPDATE view_100000
    SET Budget = 93000
    WHERE Number = 'p3';
```

Здесь компонент Database Engine проверяет, будет ли измененное значение столбца Budget 
давать значение True в условии предложения WHERE инструкции SELECT. 
Попытка изменения значения завершается неудачей, поскольку условие не удовлетворяется,
т.е. вставляемое значение 93000 не больше, чем значение 100000.

В примере ниже показано представление, которое нельзя использовать для изменения значений в таблице, на которой основано представление:

```sql
USE SampleDb;

GO
CREATE VIEW view_Pound (projectNumber, budgetPounds)
    AS SELECT Number, Budget * 0.65
    FROM Project
    WHERE Budget > 100000;

GO
SELECT *
    FROM view_Pound;
```

### Представление в котором нельзя обновить данные

Представление view_Pound нельзя использовать с инструкцией UPDATE (или с инструкцией INSERT), 
поскольку значения столбца budgetPounds являются результатом вычисления арифметического выражения, 
а не первоначальными значениями столбца таблицы, на которой основано это представление.

### Удаление данных с помощью представления

С помощью представления можно удалить строки из таблицы, на которой оно основано, как это показано в примере ниже:

```sql
USE SampleDb;

GO
CREATE VIEW view_project_p1
    AS SELECT EmpId, Job
    FROM Works_on
    WHERE ProjectNumber = 'p1';

GO
DELETE FROM view_project_p1
    WHERE Job = 'Консультант';
```

Запрос в примере создает представление, посредством которого затем удаляются строки из таблицы Works_on.
В отличие от инструкций INSERT и UPDATE, инструкция DELETE допускает значения, 
получаемые из констант или выражений, в столбце представления, 
используемого для удаления строк из таблицы, на которой оно основано.

В примере ниже показано представление, посредством которого можно удалять строки, но не вставлять строки или изменять значения столбцов:

```sql
USE SampleDb;

GO
CREATE VIEW view_budget (budgetReduction)
    AS SELECT Budget * 0.9
    FROM Project;

GO
    DELETE FROM view_budget;
```

Инструкция DELETE в примере выше удаляет все строки таблицы Project, на которой основано представление view_budget.

---

### [Табличные переменные](https://metanit.com/sql/sqlserver/10.3.php)

В Transact-SQL есть специальный тип данных для хранения результирующего набора для обработки в будущем.
Его используют в основном для временного хранения набора строк, возвращаемых как результирующий набор функций с табличным значением.
Функции и переменные могут быть объявлены как табличные переменные. 
Табличные переменные могут использоваться в функциях, хранимых процедурах и пакетах. Для объявления табличных пере-
менных используется следующий синтаксис:
```sql
DECLARE <@название переменной> TABLE (<объявление столбцов>)
```
Табличная переменная ведет себя как локальная переменная, она имеет точно определенную область применения.

Табличная переменная может быть применена в любом месте, где используется таблица
или табличное выражение в инструкциях SELECT, INSERT, UPDATE и DELETE. 
Но табличную переменную нельзя использовать в инструкции SELECT … INTO …

Табличные переменные автоматически очищаются в конце функции, хранимой процедуры или пакета, в котором они были определены.
Операция присвоения между табличными переменными не поддерживается.

Пример: Создайте табличную переменную, содержащую три столбца («Номер недели», «Дата начала», «Дата конца»).
Заполните ее для текущего года и используйте:
```sql
DECLARE @Пример4 TABLE
(
[Номер недели] INT,
[Дата начала] DATE,
[Дата конца] DATE
)
DECLARE @T AS DATE, @N INT = 1
SET @T = CAST(YEAR(GETDATE()) AS CHAR(4)) + '0101'
WHILE DATEPART(WEEKDAY, @T) > 1
SET @T = DATEADD(DAY, -1, @T)
PRINT DATEPART(WEEK, @T)
WHILE YEAR(@T) < YEAR(DATEADD(YEAR, 1, GETDATE()))
BEGIN
INSERT
@Пример4
VALUES
(@N, @T, DATEADD(DAY, 6, @T))
SET @T = DATEADD(DAY, 7, @T)
SET @N = @N + 1
END
SELECT
[Номер недели]
,[Дата начала]
,[Дата конца]
FROM
@Пример4
```

---

### [Временные таблицы](https://metanit.com/sql/sqlserver/10.4.php)

В MS SQL Server для хранения промежуточных данных можно использовать временные таблицы. 
Они по поведению не отличаются от базовых таблиц. Создание, удаление и обращение к ним аналогично к базовым.
Первый символ в названии временной таблицы должен быть знак решетки #. 
Для локальных временных таблиц используется один знак #.
Локальные временные таблицы доступны в течение текущей сессии и удаляются, когда пользователь отсоединяется от сервера.
Для глобальных временных таблиц используются два знака ##. 

Глобальные временные таблицы доступны всем открытым сессиям базы данных и удаляются, когда все пользователи,
ссылающиеся на таблицы, отсоединяются от сервера.

Временные таблицы хранятся в системной базе данных TEMPDB.

Для принудительного удаления временных таблиц используется команда DROP TABLE.

Пример: Создайте локальную временную таблицу, имеющую три столбца 
(«Название месяца», «Количество экзаменов», «Количество студентов»), заполните и используйте ее:
```sql
SELECT
DATENAME(MONTH, Дата) AS [Название месяца]
, COUNT(DISTINCT Код) AS [Количество экзаменов]
, COUNT(DISTINCT Рег_номер) AS [Количество студентов]
INTO
#Пример6
FROM
Экзамен
GROUP BY
DATENAME(MONTH, Дата)
SELECT * FROM #Пример6
```
---

### [Производные таблицы / Обобщенные табличные выражения](https://metanit.com/sql/sqlserver/10.4.php)

В MS SQL Server можно создать временно именованный результирующий набор, называемый обобщенным табличным выражением. 

Он формируется при выполнении простого запроса.

За обобщенным табличным выражением должны следовать одиночные инструкции
SELECT, INSERT, UPDATE или DELETE, ссылающиеся на некоторые или на все столбцы.
Обобщенные табличные выражения хранятся в оперативной памяти и существуют
только во время первого выполнения запроса, который представляет эту таблицу.

Обобщенное табличное выражение задается с помощью ключевого слова WITH:
```sql
WITH OrdersInfo AS
(
    SELECT ProductId, 
        SUM(ProductCount) AS TotalCount, 
        SUM(ProductCount * Price) AS TotalSum
    FROM Orders
    GROUP BY ProductId
)
 
SELECT * FROM OrdersInfo -- здесь нормально
SELECT * FROM OrdersInfo -- здесь ошибка
SELECT * FROM OrdersInfo -- здесь ошибка
```

---
