---
title: Лабораторная работа 5. Агрегатные функции и группировка
---

[Таблица учеников](assets/Students.xlsx)

[Таблица стран](assets/lab3/Страны.xlsx)

[К списку лабораторных >>>](../README.md)

---

### Задание по таблице учеников

1. Напишите запрос, который выводит максимальный балл учеников по школам,
   по каждому предмету по каждой школе и промежуточные итоги.
3. Напишите запрос, который выводит минимальный балл учеников по школам и по предметам, и промежуточные итоги.
4. Напишите запрос, который выводит средний балл учеников по школам и по предметам.
5. Напишите запрос, который выводит количество учеников по каждой школе по предметам и промежуточные итоги.
   NULL значения заменить на соответствующий текст.
6. Напишите запрос, который выводит суммарный балл учеников по школам и по предметам, и промежуточные итоги.
   В итоговых строках NULL значения заменить на соответствующий текст в зависимости от группировки.
8. Напишите запрос, который выводит максимальный балл учеников по школам и по предметам.
   В итоговых строках NULL значения заменить на соответствующий текст в зависимости от уровней группировки.
10. Напишите запрос, который выводит средний балл учеников по школам в столбцы.
11. Напишите запрос, который выводит средний балл учеников по школам в столбцы и по предметам в строки.
12. Напишите запрос, который выводит названия предметов, фамилии учеников и школы в один столбец.

---

### Задание по таблице стран

1. Вывести минимальную площадь стран.
2. Вывести наибольшую по населению страну в Северной и Южной Америке.
3. Вывести среднее население стран. Результат округлить до одного знака.
4. Вывести количество стран, у которых название заканчивается на «ан», кроме стран, у которых название заканчивается на «стан».
5. Вывести количество континентов, где есть страны, название которых начинается с буквы «Р».
6. Сколько раз страна с наибольшей площадью больше, чем страна с наименьшей площадью?
7. Вывести количество стран с населением больше, чем 100 млн. чел. на каждом континенте.
   Результат отсортировать по количеству стран по возрастанию.
9. Вывести количество стран по количеству букв в названии. Результат отсортировать по убыванию.
10. Ожидается, что через 20 лет население мира вырастет на 10%. Вывести список континентов с прогнозируемым населением:
11. Вывести список континентов, где разница по площади между наибольшими и наименьшими странами не более в 10000 раз:
12. Вывести среднюю длину названий Африканских стран.
13. Вывести список континентов, у которых средняя плотность среди стран с населением более 1 млн. чел. больше, чем 30 чел. на кв. км.
    
---

### [Агрегатные функции](https://metanit.com/sql/sqlserver/5.1.php)

Агрегатные функции используются для получения обобщающих значений. 
Они, в отличие от скалярных функций, оперируют значениями столбцов множества строк.

К агрегатным функциям относятся:
* SUM – вычисляет итог;
* MAX – возвращает наибольшее значение;
* MIN – возвращает наименьшее значение;
* AVG – вычисляет среднее значение;
* COUNT – вычисляет количество значений в столбце.

Аргументами функций выступают поля таблицы или результаты выражений над ними.
Вложенность не допускается.

Из агрегатных функций можно составлять любые выражения.

Для функций SUM и AVG столбец должен содержать числовые значения.
Выражение в функциях MIN, MAX и COUNT может представлять числовое или строковое значение или дату.

Для функций COUNT() можно указать аргумент * для подсчета всех строк без исключения.

Все агрегатные функции за исключением COUNT(*) игнорируют значения NULL.

---

### AVG

Функция Avg возвращает среднее значение на диапазоне значений столбца таблицы.

Пример. Найдем среднюю цену товаров из базы данных:

```sql
SELECT AVG(Price) AS Average_Price FROM Products
```

Также мы можем применить фильтрацию.
Пример. Найти среднюю цену для товаров какого-то определенного производителя:

```sql
SELECT AVG(Price) FROM Products
WHERE Manufacturer='Apple'
```

### COUNT
Функция Count вычисляет количество строк в выборке. Есть две формы этой функции. Первая форма COUNT(*) подсчитывает число строк в выборке:

```sql
SELECT COUNT(*) FROM Products
```

Вторая форма функции вычисляет количество строк по определенному столбцу, при этом строки со значениями NULL игнорируются:

```sql
SELECT COUNT(Manufacturer) FROM Products
```

---

### MIN и MAX

Функции Min и Max возвращают соответственно минимальное и максимальное значение по столбцу. Например, найдем минимальную цену среди товаров:

```sql
SELECT MIN(Price) FROM Products
```

Поиск максимальной цены:

```sql
SELECT MAX(Price) FROM Products
```

Данные функции также игнорируют значения NULL и не учитывают их при подсчете.

---

### SUM

Функция Sum вычисляет сумму значений столбца. Например, подсчитаем общее количество товаров:

```sql
SELECT SUM(ProductCount) FROM Products
```

Также вместо имени столбца может передаваться вычисляемое выражение. Например, найдем общую стоимость всех имеющихся товаров:

```sql
SELECT SUM(ProductCount * Price) FROM Products
```

---

### ALL и DISTINCT

По умолчанию вышеперечисленные пять функций учитывают все строки выборки для вычисления результата.

Но выборка может содержать повторяющиеся значения. Если необходимо выполнить вычисления только над уникальными значениями, 
исключив из набора значений повторяющиеся данные, то для этого применяется оператор DISTINCT (кроме COUNT(*)). 

```sql
SELECT AVG(DISTINCT ProductCount) AS Average_Price FROM Products
```

По умолчанию вместо DISTINCT применяется оператор ALL, который выбирает все строки. 

```sql
SELECT AVG(ALL ProductCount) AS Average_Price FROM Products
```

Так как этот оператор неявно подразумевается при отсутствии DISTINCT, то его можно не указывать.

### Комбинирование функций

Пример. Объединим применение нескольких функций:

```sql
SELECT COUNT(*) AS ProdCount,
       SUM(ProductCount) AS TotalCount,
       MIN(Price) AS MinPrice,
       MAX(Price) AS MaxPrice,
       AVG(Price) AS AvgPrice
FROM Products
```

---

### [Оператор GROUP BY](https://metanit.com/sql/sqlserver/5.2.php) 

Агрегатные функции можно применить не только на всю таблицу, но также на группу значений. 
Для этого применяется команда GROUP BY, которая пишется после WHERE.

После команды GROUP BY перечисляется название столбцов, по которым следует группировать данные. 

Предложение GROUP BY указывает, что результаты запроса следует разделить на группы, 
применить агрегатную функцию по отдельности к каждой группе и получить для каждой группы одну строку результатов.

В качестве элемента группировки должен выступать любой возвращаемый элемент, указанный в предложении SELECT, кроме значений агрегатных функций.

Например, сгруппируем товары по производителю

```sql
SELECT Manufacturer, COUNT(*) AS ModelsCount
FROM Products
GROUP BY Manufacturer
```

Первый столбец в выражении SELECT - Manufacturer представляет название группы, 
а второй столбец - ModelsCount представляет результат функции Count, которая вычисляет количество строк в группе.

Стоит учитывать, что любой столбец, который используется в выражении SELECT (не считая столбцов, которые хранят результат агрегатных функций), должны быть указаны после оператора GROUP BY. Так, например, в случае выше столбец Manufacturer указан и в выражении SELECT, и в выражении GROUP BY.

И если в выражении SELECT производится выборка по одному или нескольким столбцам и также используются агрегатные функции, то необходимо использовать выражение GROUP BY. Так, следующий пример работать не будет, так как он не содержит выражение группировки:

```sql
SELECT Manufacturer, COUNT(*) AS ModelsCount
FROM Products
```

Другой пример, добавим группировку по количеству товаров:

```sql
SELECT Manufacturer, ProductCount, COUNT(*) AS ModelsCount
FROM Products
GROUP BY Manufacturer, ProductCount
```

Оператор GROUP BY может выполнять группировку по множеству столбцов.

Если столбец, по которому производится группировка, содержит значение NULL, то строки со значением NULL составят отдельную группу.

Следует учитывать, что выражение GROUP BY должно идти после выражения WHERE, но до выражения ORDER BY:

```sql
SELECT Manufacturer, COUNT(*) AS ModelsCount
FROM Products
WHERE Price > 30000
GROUP BY Manufacturer
ORDER BY ModelsCount DESC
```

---

### HAVING

Команда HAVING <условие> применяется для фильтрации строк, возвращаемых при использовании предложения GROUP BY. 

HAVING пишется после GROUP BY, имеет такой формат, как WHERE, но в качестве значения используется значение, возвращаемое агрегатными функциями.

Применение HAVING во многом аналогично применению WHERE. Только если WHERE применяется к фильтрации строк, то HAVING используется для фильтрации групп.

Например, найдем все группы товаров по производителям, для которых определено более 1 модели:

```sql
SELECT Manufacturer, COUNT(*) AS ModelsCount
FROM Products
GROUP BY Manufacturer
HAVING COUNT(*) > 1
```

При этом в одной команде мы можем использовать выражения WHERE и HAVING:

```sql
SELECT Manufacturer, COUNT(*) AS ModelsCount
FROM Products
WHERE Price * ProductCount > 80000
GROUP BY Manufacturer
HAVING COUNT(*) > 1
```

То есть в данном случае сначала фильтруются строки: выбираются те товары, общая стоимость которых больше 80000. 
Затем выбранные товары группируются по производителям. И далее фильтруются сами группы - выбираются те группы, которые содержат больше 1 модели.

Если при этом необходимо провести сортировку, то выражение ORDER BY идет после выражения HAVING.

---

### [Инструкции OLAP](https://metanit.com/sql/sqlserver/5.3.php)

Дополнительно к стандартным операторам GROUP BY и HAVING SQL Server поддерживает еще четыре специальных расширения для группировки данных: ROLLUP, CUBE, GROUPING SETS и OVER.

---

### ROLLUP

Operator ROLLUP создаёт группу для каждого сочетания выражений столбцов. 
Кроме того, выполняет сведение результатов в промежуточные и общие итоги, т.е. добавляет суммирующую строку в результирующий набор.
Для этого запрос перемещается справа налево, уменьшая количество выражений столбцов, по которым он создает группы и агрегаты. 

Синтаксис команды имеет следующий вид:
```sql
GROUP BY ROLLUP(<список столбцов>)
```
или
```sql
GROUP BY <список столбцов> WITH ROLLUP
```

Пример:
```sql
SELECT Manufacturer, COUNT(*) AS Models, SUM(ProductCount) AS Units
FROM Products
GROUP BY Manufacturer WITH ROLLUP
```

Альтернативный синтаксис запроса, который можно использовать, начиная с версии MS SQL Server 2008:

```sql
SELECT Manufacturer, COUNT(*) AS Models, SUM(ProductCount) AS Units
FROM Products
GROUP BY ROLLUP(Manufacturer)
```

При группировке по нескольким критериям ROLLUP будет создавать суммирующую строку для каждой из подгрупп:

```sql
SELECT Manufacturer, COUNT(*) AS Models, SUM(ProductCount) AS Units
FROM Products
GROUP BY Manufacturer, ProductCount WITH ROLLUP
```

Порядок столбцов влияет на выходные данные ROLLUP и может отразиться на количестве строк в результирующем наборе.

GROUP BY ROLLUP(col1, col2) создает группы для каждой комбинации выражений столбцов в следующих списках:
col1, col2
col1, NULL

NULL, NULL – это общий итог.

При сортировке с помощью ORDER BY следует учитывать, что она применяется уже после добавления суммирующей строки.

---

### CUBE

Оператор CUBE создает группы для всех возможных сочетаний столбцов. 
CUBE похож на ROLLUP за тем исключением, что CUBE добавляет суммирующие строки для каждой комбинации групп.

Синтаксис команды имеет следующий вид:

```sql
GROUP BY CUBE(<список столбцов>)
```
или
```sql
GROUP BY <список столбцов> WITH CUBE
```

GROUP BY CUBE(col1, col2) создает группы для каждой комбинации выражений столбцов в следующих списках:
col1, col2
col1, NULL
NULL, col2
NULL, NULL – это общий итог.

Пример: Напишите запрос, который выводит количество учеников по предметам и по школам, и промежуточные итоги:
```sql
SELECT Предмет, Школа
,COUNT(Фамилия) AS Количество
FROM
Ученики
GROUP BY
Предмет, Школа WITH CUBE
```

Пример: Напишите запрос, который выводит количество учеников по предметам и по школам, и промежуточные итоги. 
В итоговых строках NULL значения заменить на соответствующий текст в зависимости от группировки:
```sql
SELECT
IIF(GROUPING(Предмет)=1, 'ИТОГО', Предмет) AS Предмет
,IIF(GROUPING(Школа)=1, 'Итого', Школа) AS Школа
,COUNT(Фамилия) AS Количество
FROM
Ученики
GROUP BY
CUBE(Предмет, Школа)
```

---

### GROUPING SETS

Оператор GROUPING SETS позволяет объединять несколько предложений GROUP BY в одно предложение GROUP BY. 
Оператор GROUPING SETS аналогично ROLLUP и CUBE добавляет суммирующую строку для групп. Но при этом он не включает сами группам.
Результаты эквивалентны тем, что формируются с применением конструкции UNION ALL к указанным группам. 

Синтаксис команды имеет следующий вид:

```sql
GROUP BY GROUPING SETS(<список столбцов>)
```

Пример:
```sql
SELECT Manufacturer, COUNT(*) AS Models, ProductCount
FROM Products
GROUP BY GROUPING SETS(Manufacturer, ProductCount)
```

Если параметр GROUPING SETS имеет два или более элементов, результатом будет объединение элементов.
SQL не консолидирует повторяющиеся группы, созданные для списка GROUPING SETS.

GROUP BY GROUPING SETS(col1, col2) создает группы для каждой комбинации выражений столбцов в следующих списках:
col1, NULL
NULL, col2


С помощью скобок можно определить более сложные сценарии группировки:

```sql
SELECT Manufacturer, COUNT(*) AS Models, 
        ProductCount, SUM(ProductCount) AS Units
FROM Products
GROUP BY GROUPING SETS((Manufacturer, ProductCount), ProductCount)
```

Для предложения GROUP BY, использующего ROLLUP, CUBE или GROUPING SETS, допускается максимум 32 выражения.

Пример: Напишите запрос, который выводит количество учеников по предметам и по школам:
```sql
SELECT Предмет, Школа
,COUNT(Фамилия) AS Количество
FROM
Ученики
GROUP BY
GROUPING SETS(Предмет, Школа)
```

---

### GROUPING и GROUPING_ID

Функция GROUPING указывает, является ли указанное выражение столбца в списке GROUP BY статистическим или нет. 
В результирующем наборе возврат будет 1 (статистическое выражение) или ноль (нестатистическое выражение). 
Функция GROUPING может использоваться только в предложениях SELECT, HAVING и ORDER BY, если указано предложение GROUP BY.
Функция GROUPING_ID вычисляет уровень группирования. 
Функция GROUPING_ID может использоваться только в предложениях SELECT, HAVING и ORDER BY, если указано предложение GROUP BY.

---

### OVER

Выражение OVER позволяет суммировать данные, при этому возвращая те строки, которые использовались для получения суммированных данных. 
Например, найдем количество моделей и общее количество товаров этих моделей по производителю:

```sql
SELECT ProductName, Manufacturer, ProductCount,
        COUNT(*) OVER (PARTITION BY Manufacturer) AS Models,
        SUM(ProductCount) OVER (PARTITION BY Manufacturer) AS Units
FROM Products
```

Выражение OVER ставится после агрегатной функции, затем в скобках идет выражение PARTITION BY и столбец, 
по которому выполняется группировка.

То есть в данном случае мы выбираем название модели, производителя, количество единиц модели и 
добавляем к этому количество моделей для данного производителя и общее количество единиц всех моделей производителя.

---

### PIVOT

Оператор PIVOT поворачивает возвращающее табличное значение выражение, преобразуя уникальные значения одного столбца выражения в несколько выходных столбцов. В
случае необходимости PIVOT также объединяет оставшиеся повторяющиеся значения столбца и отображает их в выходных данных.
Синтаксис PIVOT является более простым и понятным, чем синтаксис, 
который может выполнить то же действие с помощью последовательности инструкций SELECT...CASE. 

Синтаксис имеет следующий вид:
```sql
SELECT < столбцы для группировки>, <пивотируемые столбцы >
FROM
(<запрос возвращающий данных>)
AS <псевдоним>
PIVOT
(<агрегирующая функция>(<столбец>)
FOR [<столбец, значения которого будут заголовками>]
IN (<список пивотируемых столбцов>)
) AS <псевдоним для пивот-таблицы>
```

Пример: Напишите запрос для вывода количества учеников для каждой школы по каждому предмету 
(школы должны быть указаны в строках, предметы в столбцах):
```sql
SELECT
Школа, Математика, Физика, Химия
FROM
(
SELECT
Школа, Предмет, Фамилия
FROM
Ученики
) AS SOURCE_TABLE
PIVOT
(
COUNT(Фамилия)
FOR Предмет IN (Математика, Физика, Химия)
) AS PIVOT_TABLE
```

---

### UNPIVOT

Оператор UNPIVOT поворачивает возвращающее табличное значение выражения, преобразуя нескольких выходных столбцов в один столбец. 

Синтаксис имеет следующий вид:
```sql
SELECT <список столбцов>
FROM
<таблица>
UNPIVOT
(<столбец значения строк> FOR [<столбец, значения заголовок>]
IN (<список анпивотируемых столбцов>)
) AS <псевдоним для анпивот-таблицы>
```

---


