---
Блокировки: Лабораторная работа
---

[К списку лабораторных >>>](../README.md)

---

### Задание

Реализовать сценарии блокировок разного уровня, используя подсказки (задание типов блокировки):

1. deadlock
2. holdlock
3. pagelock
4. readpast
5. rowlock
6. tablock
7. updlock
 8. xlock

---

### Проблема конкурентного доступа

Данные в базе данных обычно используются совместно 
многими прикладными пользовательскими программами (приложениями). 

Ситуация, когда несколько прикладных пользовательских программ одновременно
выполняют операции чтения и записи одних и тех же данных,
называется одновременным конкурентным (параллельным) доступом (concurrency). 

Таким образом, каждая система управления базами данных должна обладать
каким-либо типом механизма управления для решения проблем,
возникающих вследствие одновременного конкурентного доступа.

В системе баз данных, которая может обслуживать большое число
активных пользовательских приложений таким образом, чтобы эти приложения не мешали друг другу,
возможен высокий уровень одновременного конкурентного доступа.

И наоборот, система баз данных, в которой разные активные приложения мешают друг другу, 
поддерживает низкий уровень одновременного конкурентного доступа.

---

### Модели одновременного конкурентного доступа

Компонент Database Engine поддерживает две разные модели одновременного конкурентного доступа:

* пессимистический одновременный конкурентный доступ;
* оптимистический одновременный конкурентный доступ.

В модели пессимистического одновременного конкурентного доступа для предотвращения 
одновременного доступа к данным, которые используются другим процессом, применяются блокировки. 
Иными словами, система баз данных, использующая модель пессимистического одновременного конкурентного доступа, 
предполагает, что между двумя или большим количеством процессов в любое время может возникнуть конфликт
и поэтому блокирует ресурсы (строку, страницу, таблицу), как только они потребуются в течение периода транзакции. 
Модель пессимистического одновременного конкурентного доступа устанавливает блокировку 
с обеспечением разделяемого доступа, иначе немонопольную блокировку (shared lock) 
на считываемые данные, чтобы никакой другой процесс не мог изменить эти данные. 
Кроме этого, механизм пессимистического одновременного конкурентного доступа 
устанавливает монопольную блокировку (exclusive lock) на изменяемые данные,
чтобы никакой другой процесс не мог их считывать или модифицировать.

Работа оптимистического одновременного конкурентного доступа основана
на предположении маловероятности изменения данных одной транзакцией одновременно с другой.
Компонент Database Engine применяет оптимистический одновременный конкурентный доступ, 
при котором сохраняются старые версии строк, и любой процесс при чтении данных
использует ту версию строки, которая была активной, когда он начал чтение.
Поэтому процесс может модифицировать данные без каких-либо ограничений, 
поскольку все другие процессы, которые считывают эти же данные,
используют свою собственную сохраненную версию. 

Конфликтная ситуация возможна только при попытке двух операций записи 
использовать одни и те же данные. 
В таком случае система выдает ошибку, которая обрабатывается клиентским приложением.

Понятие оптимистического одновременного конкурентного доступа 
обычно определяется в более широком смысле. 
Работа управления оптимистического одновременного конкурентного доступа 
основана на предположении маловероятности конфликтов между несколькими пользователями, 
поэтому разрешается исполнение транзакций без установки блокировок. 
Только когда пользователь пытается изменить данные, выполняется проверка ресурсов,
чтобы определить наличие конфликтов.
Если таковые возникли, то приложение требуется перезапустить.

---

### Блокировки

Одновременный конкурентный доступ может вызывать разные отрицательные эффекты, 
например чтение несуществующих данных или потерю модифицированных данных. 

Рассмотрим следующий практический пример, иллюстрирующий один из этих отрицательных эффектов, называемый грязным чтением. 

Пользователь U1 из отдела кадров получает извещение, что сотрудник "Василий Фролов" поменял место жительства. 
Он вносит соответствующее изменение в базу данных для данного сотрудника, 
но при просмотре другой информации об этом сотруднике он понимает, что изменил адрес не того человека. 
(В компании работают два сотрудника по имени Василий Фролов.) 
К счастью, приложение позволяет отменить это изменение одним нажатием кнопки. 
Он нажимает эту кнопку, уверенный в том, что данные после отмены операции изменения адреса уже не содержат никакой ошибки.

В то же самое время пользователь U2 в отделе проектирования обращается к данным 
второго сотрудника с именем Василий Фролов, чтобы отправить ему домой последнюю техническую документацию, 
поскольку этот служащий редко бывает в офисе. 
Однако пользователь U2 обратился к базе данных после того, 
как адрес этого второго сотрудника с именем Василий Фролов был ошибочно изменен, но до того, как он был исправлен. 
В результате письмо отправляется не тому адресату.

Чтобы предотвратить подобные проблемы в модели пессимистического одновременного конкурентного доступа, 
которую мы кратко описали в предыдущей статье, каждая система управления базами данных должна обладать 
механизмом для управления одновременным доступом к данным всеми пользователями. 
Для обеспечения согласованности данных в случае одновременного обращения к данным несколькими пользователями 
компонент Database Engine, подобно всем СУБД, применяет блокировки.
Каждая прикладная программа блокирует требуемые ей данные, что гарантирует,
что никакая другая программа не сможет модифицировать эти данные. 
Когда другая прикладная программа пытается получить доступ к заблокированным данным для их модификации, 
то система или завершает эту попытку ошибкой, или заставляет программу ожидать снятия блокировки.

Блокировка имеет несколько разных свойств: длительность блокировки, режим блокировки и гранулярность блокировки.

Длительность блокировки - это период времени, в течение которого ресурс удерживает определенную блокировку. 
Длительность блокировки зависит, среди прочего, от режима блокировки и выбора уровня изоляции.

Режимы блокировки и уровень гранулярности блокировки рассматриваются в следующих двух разделах. 
Последующее обсуждение относится к модели пессимистического одновременного конкурентного доступа. 
Модель оптимистического одновременного конкурентного доступа основана 
на управлении версиями строк и рассматривается в последующих статьях.

### Режимы блокировки

Режимы блокировки определяют разные типы блокировок. 
Выбор определенного режима блокировки зависит от типа ресурса, который требуется заблокировать. 
Для блокировок ресурсов уровня строки и страницы применяются следующие три типа блокировок:

#### Разделяемая блокировка (shared lock)
Резервирует ресурс (страницу или строку) только для чтения. 
Другие процессы не могут изменять заблокированный таким образом ресурс, 
но, с другой стороны, несколько процессов могут одновременно накладывать 
разделяемую блокировку на один и тот же ресурс. 
Иными словами, чтение ресурса с разделяемой блокировкой могут одновременно выполнять несколько процессов.

#### Монопольная блокировка (exclusive lock)
Резервирует страницу или строку для монопольного использования одной транзакции. 
Блокировка этого типа применяется инструкциями DML (INSERT, UPDATE и DELETE), которые модифицируют ресурс. 
Монопольную блокировку нельзя установить, если на ресурс уже установлена
разделяемая или монопольная блокировка другим процессом, 
т.е. на ресурс может быть установлена только одна монопольная блокировка. 
На ресурс (страницу или строку) с установленной монопольной блокировкой нельзя установить никакую другую блокировку.

#### Блокировка обновления (update lock)
Может быть установлена на ресурс только при отсутствии на нем 
другой блокировки обновления или монопольной блокировки. 
С другой стороны, этот тип блокировки можно устанавливать на объекты с установленной разделяемой блокировкой.
В таком случае блокировка обновления накладывает на объект другую разделяемую блокировку. 
Если транзакция, которая модифицирует объект, подтверждается, 
и у объекта нет никаких других блокировок, блокировка обновления преобразовывается в монопольную блокировку. 
У объекта может быть только одна блокировка обновления.

Система баз данных автоматически выбирает соответствующий режим блокировки,
в зависимости от типа операции (чтение или запись).
Блокировка обновления применяется для предотвращения определенных распространенных типов взаимоблокировок.

Возможность совмещения разных типов блокировок приводится в таблице ниже:
		
| --- | Разделяемая | Обновления | Монопольная |
|----------|----------|----------|----------|
| Разделяемая | Да    | Да   | Нет   |
| Обновления | Да    | Нет   | Нет  |
| Монопольная | Нет    | Нет   | Нет   |

Эта таблица интерпретируется следующим образом: 
предположим транзакция T1 имеет блокировку, указанную в заголовке соответствующей строки таблицы, 
а транзакция T2 запрашивает блокировку, указанную в соответствующем заголовке столбца таблицы.
Значение "Да" в ячейке на пресечении строки и столбца означает, 
что транзакция T2 может иметь запрашиваемый тип блокировки, а значение "Нет", что не может.

Компонент Database Engine также поддерживает и другие типы блокировок, 
такие как кратковременные блокировки (latch lock) и взаимоблокировки (spin lock).

На уровне таблицы существует пять разных типов блокировок:

* разделяемая (shared, S);
* монопольная (exclusive, X);
* разделяемая с намерением (intent shared, IS);
* монопольная с намерением (intent exclusive, IX);
* разделяемая с монопольным намерением (shared with intent exclusive, SIX).

Разделяемые и монопольные типы блокировок для таблицы соответствуют одноименным блокировкам для строк и страниц. 
Обычно блокировка с намерением (intent lock) означает, что транзакция намеревается 
блокировать следующий нижележащий в иерархии объектов базы данных ресурс. 
Таким образом, блокировка с намерением помещается на уровне иерархии объектов, 
который выше того объекта, который этот процесс намеревается заблокировать.
Это является действенным способом узнать, возможна ли подобная блокировка,
а также устанавливается запрет другим процессам блокировать более высокий уровень,
прежде чем процесс может установить требуемую ему блокировку.

Возможность совмещения разных типов блокировок на уровне таблиц базы данных приведена в таблице ниже. 
Эта таблица интерпретируется точно таким же образом, как и предыдущая таблица

| --- |	S |	X |	IS	| SIX |	IX |
|----------|----------|----------|----------|----------|----------|
|	S |	Да |	Нет |	Да |	Нет |	Нет |
|	X |	Нет |	Нет |	Нет |	Нет |	Нет |
|	IS |	Да |	Нет |	Да |	Да |	Да |
|	SIX |	Нет |	Нет |	Да |	Нет |	Нет |
|	IX |	Нет |	Нет |	Да |	Нет |	Да |

### Гранулярность блокировки

Гранулярность блокировки определяет, какой ресурс блокируется в одной попытке блокировки. 
Компонент Database Engine может блокировать следующие ресурсы: 
строки, страницы, индексный ключ или диапазон индексных ключей, 
таблицы, экстент, саму базу данных. Система выбирает требуемую гранулярность блокировки автоматически.

Строка является наименьшим ресурсом, который можно заблокировать. 
Блокировка уровня строки также включает как строки данных, так и элементы индексов. 
Блокировка на уровне строки означает, что блокируется только строка, к которой обращается приложение. 
Поэтому все другие строки данной таблицы остаются свободными и их могут использовать другие приложения. 
Компонент Database Engine также может заблокировать страницу, на которой находится подлежащая блокировке строка.

В кластеризованных таблицах страницы данных хранятся на уровне узлов (кластеризованной) индексной структуры, 
и поэтому для них вместо блокировки строк применяется блокировка с индексными ключами.

Блокироваться также могут единицы дискового пространства, которые называются экстентами и имеют размер 64 Кбайт.
Экстенты блокируются автоматически, и когда растет таблица или индекс, 
то для них требуется выделять дополнительное дисковое пространство.

Гранулярность блокировки оказывает влияние на одновременный конкурентный доступ. 
В общем, чем выше уровень гранулярности, тем больше сокращается возможность совместного доступа к данным. 
Это означает, что блокировка уровня строк максимизирует одновременный конкурентный доступ, 
т.к. она блокирует всего лишь одну строку страницы, оставляя все другие строки доступными для других процессов.
C другой стороны, низкий уровень блокировки увеличивает системные накладные расходы, 
поскольку для каждой отдельной строки требуется отдельная блокировка. 
Блокировка на уровне страниц и таблиц ограничивает уровень доступности данных, 
но также уменьшает системные накладные расходы.

### Укрупнение блокировок

Если в процессе транзакции имеется большое количество блокировок одного уровня, 
то компонент Database Engine автоматически объединяет эти блокировки в одну уровня таблицы.
Этот процесс преобразования большого числа блокировок уровня строки, 
страницы или индекса в одну блокировку уровня таблицы называется укрупнением блокировок (lock escalation).
Порогом укрупнения называется граница, на которой система баз данных применяет укрупнение блокировок.
Пороги укрупнения устанавливаются динамически системой и не требуют настройки. 
(В настоящее время пороговым значением укрупнения блокировок является 5000 блокировок.)

Основной проблемой, касающейся укрупнения блокировок, является то обстоятельство, 
что решение, когда осуществлять укрупнение, принимает сервер баз данных, 
и это решение может не быть оптимальным для приложений, имеющих различные требования.
Механизм укрупнения блокировок можно модифицировать с помощью инструкции ALTER TABLE. 
Эта инструкция поддерживает параметр TABLE и имеет следующий синтаксис:

```sql
ALTER TABLE table_name 
	SET ( LOCK_ESCALATION = { TABLE | AUTO | DISABLE } )
```

Параметр table является значением по умолчанию и задает укрупнение блокировок на уровне таблиц. 
Параметр auto позволяет компоненту Database Engine самому выбирать уровень гранулярности, 
который соответствует схеме таблицы. Наконец, параметр disable отключает укрупнение блокировок в большинстве случаев. 
(В некоторых случаях компоненту Database Engine требуется наложить блокировку на уровне таблиц, чтобы предохранить целостность данных.)

В примере ниже показана отмена укрупнения блокировок для таблицы Employee:

```sql
USE SampleDb;

ALTER TABLE Employee SET (LOCK_ESCALATION = DISABLE);
```

### Настройка блокировок

Настройку блокировок можно осуществлять, используя подсказки блокировок (locking hints) 
или параметр LOCK_TIMEOUT инструкции SET. Эти возможности описываются в следующих разделах.

### Подсказки блокировок (locking hints)

Подсказки блокировок задают тип блокировки, используемой компонентом Database Engine для блокировки табличных данных.

Подсказки блокировки уровня таблиц применяются, когда требуется более точное управление типами блокировок, накладываемых на ресурс. 
(Подсказки блокировок перекрывают текущий уровень изоляции для сеанса.)

Все подсказки блокировок указываются в предложении FROM инструкции SELECT.

Далее приводится список и краткое описание доступных подсказок блокировок:

#### UPDLOCK

Устанавливается блокировка обновления для каждой строки таблицы при операции чтения. Все блокировки обновления удерживаются до окончания транзакции.

#### TABLOCK

Устанавливается разделяемая (или монопольная) блокировка для таблицы. Все блокировки удерживаются до окончания транзакции.

#### ROWLOCK

Существующая разделяемая блокировка таблицы заменяется разделяемой блокировкой строк для каждой отвечающей требованиям строки таблицы.

#### PAGLOCK

Разделяемая блокировка таблицы заменяется разделяемой блокировкой страницы для каждой страницы, содержащей указанные строки.

#### NOLOCK

Синоним для READUNCOMMITTED, который мы рассмотрим при обсуждении уровней изоляции.

#### HOLDLOCK

Синоним для REPEATABLEREAD.

#### XLOCK

Устанавливается монопольная блокировка, удерживаемая до завершения транзакции. Если подсказка xlock указывается с подсказкой rowlock, paglock или tablock, монопольные блокировки устанавливаются на соответствующем уровне гранулярности.

#### READPAST

Указывает, что компонент Database Engine не должен считывать строки, заблокированные другими транзакциями.

Все эти параметры можно объединять вместе в любом имеющем смысл порядке. 
Например, комбинация подсказок TABLOCK с PAGLOCK не имеет смысла, поскольку каждая из них применяется для разных ресурсов.

####  Параметр LOCK_TIMEOUT

Чтобы процесс не ожидал освобождения блокируемого объекта до бесконечности, 
можно в инструкции SET использовать параметр LOCK_TIMEOUT. 
Этот параметр задает период в миллисекундах, в течение которого транзакция будет ожидать снятия блокировки с объекта. 

Например, если вы хотите чтобы период ожидания был равен восемь секунд, то это следует указать следующим образом:
```sql
SET LOCK_TIMEOUT 8000
```

Если данный ресурс не может быть предоставлен процессу в течение этого периода времени, 
инструкция завершается аварийно и выдается соответствующее сообщение об ошибке. 
Значение LOCK_TIMEOUT равное -1 (значение по умолчанию) указывает отсутствие периода ожидания, 
т.е. транзакция не будет ожидать освобождения ресурса совсем. 
(Подсказка блокировки READPAST предоставляет альтернативу параметру LOCK_TIMEOUT.)

###  Отображение информации о блокировках

Наиболее важным средством для отображения информации о блокировках является 
динамическое административное представление sys.dm_tran_locks. 
Это представление возвращает информацию о текущих активных ресурсах диспетчера блокировок. 
Каждая строка представления отображает активный в настоящий момент запрос на блокировку, 
которая была предоставлена или предоставление которой ожидается. 
Столбцы представления соответствуют двум группам: ресурсам и запросам. 
Группа ресурсов описывает ресурсы, на блокировку которых делается запрос, 
а группа запросов описывает запрос блокировки. 

Наиболее важными столбцами этого представления являются следующие:

* resource_type - указывает тип ресурса;
* resource_database_id - задает идентификатор базы данных, к которой принадлежит данный ресурс;
* request_mode - задает режим запроса;
* request_status - задает текущее состояние запроса.

В примере ниже показан запрос, использующий представление sys.dm_tran_locks для отображения блокировок в состоянии ожидания:
```sql
USE SampleDb;

SELECT resource_type, DB_NAME(resource_database_id) as db_name,
    request_session_id, request_mode, request_status
    FROM sys.dm_tran_locks
    WHERE request_status = 'WAIT;'
```

### Взаимоблокировки

Взаимоблокировка (deadlock) - это особая проблема одновременного конкурентного доступа,
в которой две транзакции блокируют друг друга. 
В частности, первая транзакция блокирует объект базы данных, 
доступ к которому хочет получить другая транзакция, и наоборот. 
(В общем, взаимоблокировка может быть вызвана несколькими транзакциями, которые создают цикл зависимостей.) 

В примере ниже показана взаимоблокировка двумя транзакциями. 
(При использовании базы данных небольшого размера, одновременный конкурентный доступ процессов 
нельзя получить естественным образом, вследствие очень быстрого выполнения каждой транзакции. 
Поэтому в примере ниже используется инструкция WAITFOR, 
чтобы приостановить обе транзакции на десять секунд, чтобы эмулировать взаимоблокировку.)

```sql
USE SampleDb;

BEGIN TRANSACTION                            BEGIN TRANSACTION
    UPDATE Works_on                                UPDATE Employee
        SET Job = 'Менеджер'                       SET DepartamentNumber = 'd2'                
        WHERE EmpId = 25348                            WHERE Id = 28559
        AND ProjectNumber = 'p2'
    
    WAITFOR DELAY '00:00:10'                    WAITFOR DELAY '00:00:10'

    UPDATE Employee                                DELETE FROM Works_on
        SET LastName = 'Фролова'                   WHERE EmpId = 25348
        WHERE LastName = 'Вершинина'                    AND ProjectNumber = 'p2'
COMMIT                                        COMMIT
```

Если обе транзакции в примере выше будут выполняться в одно и то же время, 
то возникнет взаимоблокировка и система возвратит следующее сообщение об ошибке:

```sql
Сообщение 1205, уровень 13, состояние 45

Транзакция (процесс с идентификатором 56) находится во взаимной
блокировке с другим процессом и выбрана в качестве потерпевшей 
взаимоблокировки. Повторите выполнение команды.)
```

Как можно видеть по результатам выполнения примера, система баз данных обрабатывает взаимоблокировку, 
выбирая одну из транзакций (на самом деле, транзакцию, которая замыкает цикл в запросах блокировки) 
в качестве "жертвы" и выполняя ее откат. После этого выполняется другая транзакция.
На уровне прикладной программы взаимоблокировку можно обрабатывать посредством реализации условной инструкции,
которая выполняет проверку на возврат номера ошибки (1205), а затем снова выполняет инструкцию, для которой был выполнен откат.

Вы можете повлиять на то, какая транзакция будет выбрана системой в качестве "жертвы" взаимоблокировки, 
присвоив в инструкции SET параметру DEADLOCK_PRIORITY один из 21 (от -10 до 10)
разных уровней приоритета взаимоблокировки. 
Константа LOW соответствует значению -5,
NORMAL (значение по умолчанию) - значению 0, 
а константа HIGH - значению 5.

Сеанс "жертва" выбирается в соответствии с приоритетом взаимоблокировки сеанса.


