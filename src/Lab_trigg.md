---
Триггеры: Лабораторная работа
---

[Таблица учеников](assets/lab5/Pupils.xlsx)

[К списку лабораторных >>>](../README.md)

---

### Задание по таблице учеников

1. Напишите триггер на изменение записи в таблице «Ученики». Данный триггер, в случае изменения данных, должен вывести «Запись изменена».
2. Напишите триггер на добавление и удаление записи из таблицы «Ученики». Данный триггер, в случае успешного добавления или удаления данных, должен вывести «Количество строк изменено: {количество измененных/затронутых строк}».
3. Напишите триггер на добавление, изменение и удаление данных в таблице «Ученики». Данный триггер должен вывести «{Текущий пользователь} изменил таблицу. Время: {текущее время}».
4. Напишите триггер на изменение записи в таблице «Ученики». Данный триггер, при попытке изменения данных, должен вывести «Нельзя редактировать данные».
5. Создать таблицу «Ученики_{Ваша_фамилия}», которая будет содержать фамилии удаленных учеников и даты их удаления. Написать триггер, который будет фиксировать в таблице «Ученики_{Ваша_фамилия}» данные учеников при удалении из таблицы «Ученики», в том случае, если у них остались однофамильцы в таблице «Ученики».
6. Напишите команды для приостановления и запуска триггера из предыдущей задачи.
7. Напишите команды для удаления всех созданных вами триггеров.

---

### Триггеры

Триггер – это вид хранимой процедуры, который вызывается автоматически при опре-деленных событиях. Часто триггеры применяются для автоматической поддержки целостно-сти и защиты БД.
В MS SQL Server существует три вида триггеров, которые отличаются по функциям и по синтаксису создания и изменения: Триггеры DML вызываются при выполнении команд INSERT, UPDATE или DELETE. Можно создать триггер, реагирующий на две или на все три команды. Триггеры DDL реагируют на события изменения структуры БД: создание, изменение или удаление отдельных объектов БД. Триггеры входа в систему запускаются при соединении пользователя с экземпляром сервера. Их можно применять для дополнительной проверки полномочий пользователей.
Триггеры DML можно вызвать после событий (FOR | AFTER), или вместо него (INSTEAD OF).
Триггер AFTER выполняется после успешного завершения вызвавшего его события. Можно определить несколько АFТЕR-триггеров для каждой операции.
Триггер INSTEAD OF вызывается вместо выполнения команд. Для каждой операции INSERT, UPDATE, DELETE можно определить только один INSTEAD ОF-триггер.

---

### [Создание триггеров](https://metanit.com/sql/sqlserver/12.1.php)

Упрощенный синтаксис создания триггера имеет следующий вид:
```sql
CREATE TRIGGER <название триггера> ON <название таблицы>
<FOR | AFTER | INSTEAD OF> <INSERT | UPDATE | DELETE>
AS
[BEGIN]
<команды>
[END]
```
---

### Приостановление триггеров

Если при определенных обстоятельствах выполнение триггера нежелательно, то можно его отключить. Для этого используется команда DISABLE TRIGGER, его синтаксис:
```sql
DISABLE TRIGGER <название триггера> ON <название таблицы>
```
А когда триггер снова понадобится, его можно включить с помощью команды ENABLE TRIGGER, его синтаксис:
```sql
ENABLE TRIGGER <название триггера> ON <название таблицы>
```

---

### Удаление триггеров

Для удаления триггера используется команда DROP TRIGGER, его синтаксис:
```sql
DROP TRIGGER <название триггера>
```

---

### [Триггеры после событий](https://metanit.com/sql/sqlserver/12.2.php)

Ключевое слово FOR или AFTER указывает, что триггер DML срабатывает только 
после успешного запуска всех операций в инструкции SQL, по которой срабатывает триггер.

В определении триггера ключевые слова INSERT | UPDATE | DELETE определяют инструкции изменения данных, 
при применении которых к таблице или представлению срабатывает триггер DML. 
Указание хотя бы одного варианта обязательно. 

В определении триггера после событий разрешены любые сочетания вариантов в любом порядке.

Триггеры не вызываются рекурсивно.

Хотя инструкция TRUNCATE TABLE по сути аналогичная инструкции DELETE, она не активирует триггер.

#### Добавление

При добавлении данных (при выполнении команды INSERT) в триггере мы можем получить добавленные данные из виртуальной таблицы INSERTED.

Определим триггер, который будет срабатывать после добавления:

```sql
USE productsdb
GO
CREATE TRIGGER Products_INSERT
ON Products
AFTER INSERT
AS
INSERT INTO History (ProductId, Operation)
SELECT Id, 'Добавлен товар ' + ProductName + '   фирма ' + Manufacturer
FROM INSERTED
```

Этот триггер будет добавлять в таблицу History данные о добавлении товара, которые берутся из виртуальной таблицы INSERTED.

#### Удаление данных

При удалении все удаленные данные помещаются в виртуальную таблицу DELETED:

```sql
USE productsdb
GO
CREATE TRIGGER Products_DELETE
ON Products
AFTER DELETE
AS
INSERT INTO History (ProductId, Operation)
SELECT Id, 'Удален товар ' + ProductName + '   фирма ' + Manufacturer
FROM DELETED
```

Здесь, как и в случае с предыдущим триггером, помещаем информацию об удаленных товарах в таблицу History.

#### Изменение данных

Триггер обновления данных срабатывает при выполнении операции UPDATE. И в таком триггере мы можем использовать две виртуальных таблицы. Таблица INSERTED хранит значения строк после обновления, а таблица DELETED хранит те же строки, но до обновления.

Создадим триггер обновления:

```sql
USE productsdb
GO
CREATE TRIGGER Products_UPDATE
ON Products
AFTER UPDATE
AS
INSERT INTO History (ProductId, Operation)
SELECT Id, 'Обновлен товар ' + ProductName + '   фирма ' + Manufacturer
FROM INSERTED
```

И при обновлении данных сработает данный триггер.

---

### [Триггеры вместо событий](https://metanit.com/sql/sqlserver/12.3.php)

Ключевое слово INSTEAD OF указывает, что триггер DML выполняется вместо инструкции SQL, 
по которой он срабатывает, то есть переопределяет действия запускающих инструкций.

Он определяется также, как триггер AFTER, за тем исключением, 
что он может определяться только для одной операции - INSERT, DELETE или UPDATE.

И также он может применяться как для таблиц, так и для представлений (триггер AFTER применяется только для таблиц).

Определим триггер для удаления записи:

```sql
USE prods
GO
CREATE TRIGGER products_delete
ON Products
INSTEAD OF DELETE
AS
UPDATE Products
SET IsDeleted = 1
WHERE ID =(SELECT Id FROM deleted)
```

Добавим некоторые данные в таблицу и выполним удаление из нее:

```sql
USE prods;
 
INSERT INTO Products(ProductName, Manufacturer, Price)
VALUES ('iPhone X', 'Apple', 79000),
('Pixel 2', 'Google', 60000);
 
DELETE FROM Products 
WHERE ProductName='Pixel 2';
 
SELECT * FROM Products;
```

Таким образом, удаляемые записи на самом деле не будут удаляться, просто у них будет устанавливаться значение для столбца IsDeleted.

---

### Виртуальные таблицы в триггерах

Если триггер выполняется для события добавления данных (команды INSERT), 
в теле триггера доступна виртуальная таблица INSERTED, которая содержит список добавленных данных.
Если триггер выполняется для события удаления данных (команды DELETE),
в теле триггера доступна виртуальная таблица DELETED, которая содержит список удаленных данных.
Если триггер выполняется для события изменения данных (команды UPDATE), 
в теле триггера доступны две виртуальные таблицы INSERTED и DELETED, которые содержат список новых и старых данных, соответственно.

---
