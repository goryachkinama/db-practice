---
title: Лабораторная работа 8. Представления. Табличные объекты. Пользовательские функции
---

[Таблица стран](assets/lab3/Страны.xlsx)

[Таблицы студентов](assets/lab6/Students.xlsx)

[Вариант 2](assets/lab/v2.md)

[К списку лабораторных >>>](../README.md)

---

### Часть 1. Задания по таблицам студентов

1. Создайте представление, содержащее фамилии преподавателей, их должность, звание, степень, место работы, количество их экзаменов, и используйте его.
2. С помощью обобщенных табличных выражений напишите запрос для вывода списка сотрудников, чьи зарплаты меньше, чем средняя зарплата по факультету, их зарплаты и название факультета.
3. Создайте локальную временную таблицу, имеющую три столбца («Номер недели», «Количество экзаменов», «Количество студентов»), заполните и используйте ее.
4. Напишите команды для удаления всех созданных вами представлений.

---

### Часть 2. Задание по таблице стран

1. Создайте представление, содержащее список африканских стран, население которых больше 10 млн. чел., а площадь больше 500 тыс. кв. км, и используйте его.
2. Создайте представление, содержащее список континентов, среднюю площадь стран, которые находятся на нем, среднюю плотность населения, и используйте его.
3. Создайте табличную переменную, содержащую список стран, площадь которых в 100 раз меньше, чем средняя площадь стран на континенте, где они находятся, и используйте ее.
4. Создайте глобальную временную таблицу, содержащую название континентов, наибольшую и наименьшую площадь стран на них, заполните и используйте ее.
5. Создайте глобальную временную таблицу, содержащую название стран и плотность их населения, заполните и используйте ее.
6. Напишите команды для удаления всех созданных вами представлений.

---

### Часть 3. Задание по пользовательским функциям по таблице стран

1. Напишите функцию для вывода названия страны с заданной столицей, и вызовите ее.
2. Напишите функцию для перевода населения в млн. чел. и вызовите ее.
3. Напишите функцию для вычисления плотности населения заданной части света и вызовите ее.
4. Напишите функцию для поиска страны, третьей по населению и вызовите ее.
5. Напишите функцию для поиска страны с максимальным населением в заданной части света и вызовите ее. Если часть света не указана, выбрать Азию.
6. Напишите функцию для замены букв в заданном слове от третьей до предпоследней на “тест” и примените ее для столицы страны.
7. Напишите функцию, которая возвращает количество стран, не содержащих в названии заданную букву.
8. Напишите функцию для возврата списка стран с площадью меньше заданного числа и вызовите ее.
9. Напишите функцию для возврата списка стран с населением в интервале заданных значений и вызовите ее.
10. Напишите функцию для возврата таблицы с названием континента и суммарным населением и вызовите ее.
11. Напишите код для удаления созданных вами функций.

---

### Часть 4. Задания не по таблицам

1. Создайте табличную переменную, содержащую три столбца («Номер месяца», «Название месяца», «Количество дней»), заполните ее для текущего года, и используйте ее.
2. Напишите функцию IsPalindrom(P) целого типа, возвращающую 1, если целый параметр P (P > 0) является палиндромом, и 0 в противном случае.
3. Напишите функцию Quarter(x, y) целого типа, определяющую номер координатной четверти, содержащей точку с ненулевыми вещественными координатами (x, y).
4. Напишите функцию IsPrime(N) целого типа, возвращающую 1, если целый параметр N (N > 1) является простым числом, и 0 в противном случае.
5. Напишите команды для удаления всех созданных вами представлений и функций.

---

### Часть 5. Задание по таблицам из демо-экзамена

На основе разработанных таблиц реализовать представления и функции, необходимые для правильной работы приложения (фильтрация, сортировка, постраничный вывод и пр)
[Вариант 2](assets/lab/v2.md)

---

### [Представления](https://metanit.com/sql/sqlserver/10.1.php)

Представление – это виртуальная таблица, содержимое которой определяется запросом. 
Как и таблица, представление состоит из ряда именованных столбцов и строк данных.

Представления, как таблицы, могут иметь до 1024 столбцов.
Запрос для создания представления может обращаться не более чем к 256 таблицам.

Можно создавать представления на основе других представлений, при этом уровень
вложенности не может быть больше 32-х.

Представление можно использовать как обычную таблицу.
Упрощенный синтаксис создания преставления имеет следующий вид:
```sql
CREATE VIEW <название> <список столбцов>
AS <запрос SELECT>
```
Запрос SELECT, используемый в определении представления, не может включать предложение ORDER BY, 
если только в списке выбора инструкции SELECT нет также предложения TOP.

Для удаления представления используется команда DROP VIEW, его синтаксис:
```sql
DROP VIEW <название>
```
---

### [Обновляемое представление](https://metanit.com/sql/sqlserver/10.2.php)

Представления могут быть обновляемыми (updatable). В таких представлениях мы можем изменить или удалить строки или добавить в них новые строки.

При создании подобных представлений есть множество ограничений. В частности, команда SELECT при создании обновляемого представления не может содержать:

* TOP
* DISTINCT
* UNION
* JOIN
* агрегатные функции типа COUNT или MAX
* GROUP BY и HAVING
* подзапросы
* производные столбцы или столбцы, которые вычисляются на основании нескольких значений
* обращения одновременно к нескольким таблицам

Стоит отметить, что это касается именно обновляемого представления. 

Например, для создания обычного представления мы можем использовать в команде SELECT оператор JOIN, 
однако такое представление не будет обновляемым. 
При попытке его обновить, мы будем получать ошибку вида 
"View or function название_представления is not updatable because the modification affects multiple base tables."

### [Обновление данных с помощью представления](https://professorweb.ru/my/sql-server/2012/level3/3_7.php)

Инструкцию UPDATE можно применять с представлением, как будто бы это была базовая таблица. При модифицировании строк представления также модифицируется содержимое таблицы в его основе. Запрос в примере создает представление, посредством которого затем модифицируется таблица Works_on:

```sql
USE SampleDb;

GO
CREATE VIEW view_p1
    AS SELECT EmpId, Job
    FROM Works_on
    WHERE ProjectNumber = 'p1';

GO
UPDATE view_p1
    SET Job = NULL
    WHERE Job = 'Менеджер';
```

Операцию обновления представления view_p1 в примере выше можно рассматривать 
эквивалентной выполнению следующей инструкции UPDATE:

```sql
UPDATE Works_on
    SET Job = NULL
    WHERE Job = 'Менеджер'
        AND ProjectNumber = 'p1';
```

Логическое значение предложения WITH CHECK OPTION для инструкции UPDATE имеет такое же значение,
как и для инструкции INSERT. Использование предложения WITH CHECK OPTION в инструкции UPDATE показано в примере ниже:

```sql
USE SampleDb;

GO
CREATE VIEW view_100000
    AS SELECT Number, Budget
    FROM Project
    WHERE Budget > 100000
    WITH CHECK OPTION;

GO
UPDATE view_100000
    SET Budget = 93000
    WHERE Number = 'p3';
```

Здесь компонент Database Engine проверяет, будет ли измененное значение столбца Budget 
давать значение True в условии предложения WHERE инструкции SELECT. 
Попытка изменения значения завершается неудачей, поскольку условие не удовлетворяется,
т.е. вставляемое значение 93000 не больше, чем значение 100000.

В примере ниже показано представление, которое нельзя использовать для изменения значений в таблице, на которой основано представление:

```sql
USE SampleDb;

GO
CREATE VIEW view_Pound (projectNumber, budgetPounds)
    AS SELECT Number, Budget * 0.65
    FROM Project
    WHERE Budget > 100000;

GO
SELECT *
    FROM view_Pound;
```

### Представление в котором нельзя обновить данные

Представление view_Pound нельзя использовать с инструкцией UPDATE (или с инструкцией INSERT), 
поскольку значения столбца budgetPounds являются результатом вычисления арифметического выражения, 
а не первоначальными значениями столбца таблицы, на которой основано это представление.

### Удаление данных с помощью представления

С помощью представления можно удалить строки из таблицы, на которой оно основано, как это показано в примере ниже:

```sql
USE SampleDb;

GO
CREATE VIEW view_project_p1
    AS SELECT EmpId, Job
    FROM Works_on
    WHERE ProjectNumber = 'p1';

GO
DELETE FROM view_project_p1
    WHERE Job = 'Консультант';
```

Запрос в примере создает представление, посредством которого затем удаляются строки из таблицы Works_on.
В отличие от инструкций INSERT и UPDATE, инструкция DELETE допускает значения, 
получаемые из констант или выражений, в столбце представления, 
используемого для удаления строк из таблицы, на которой оно основано.

В примере ниже показано представление, посредством которого можно удалять строки, но не вставлять строки или изменять значения столбцов:

```sql
USE SampleDb;

GO
CREATE VIEW view_budget (budgetReduction)
    AS SELECT Budget * 0.9
    FROM Project;

GO
    DELETE FROM view_budget;
```

Инструкция DELETE в примере выше удаляет все строки таблицы Project, на которой основано представление view_budget.

---

### [Табличные переменные](https://metanit.com/sql/sqlserver/10.3.php)

В Transact-SQL есть специальный тип данных для хранения результирующего набора для обработки в будущем.
Его используют в основном для временного хранения набора строк, возвращаемых как результирующий набор функций с табличным значением.
Функции и переменные могут быть объявлены как табличные переменные. 
Табличные переменные могут использоваться в функциях, хранимых процедурах и пакетах. Для объявления табличных пере-
менных используется следующий синтаксис:
```sql
DECLARE <@название переменной> TABLE (<объявление столбцов>)
```
Табличная переменная ведет себя как локальная переменная, она имеет точно определенную область применения.

Табличная переменная может быть применена в любом месте, где используется таблица
или табличное выражение в инструкциях SELECT, INSERT, UPDATE и DELETE. 
Но табличную переменную нельзя использовать в инструкции SELECT … INTO …

Табличные переменные автоматически очищаются в конце функции, хранимой процедуры или пакета, в котором они были определены.
Операция присвоения между табличными переменными не поддерживается.

Пример: Создайте табличную переменную, содержащую три столбца («Номер недели», «Дата начала», «Дата конца»).
Заполните ее для текущего года и используйте:
```sql
DECLARE @Пример4 TABLE
(
[Номер недели] INT,
[Дата начала] DATE,
[Дата конца] DATE
)
DECLARE @T AS DATE, @N INT = 1
SET @T = CAST(YEAR(GETDATE()) AS CHAR(4)) + '0101'
WHILE DATEPART(WEEKDAY, @T) > 1
SET @T = DATEADD(DAY, -1, @T)
PRINT DATEPART(WEEK, @T)
WHILE YEAR(@T) < YEAR(DATEADD(YEAR, 1, GETDATE()))
BEGIN
INSERT
@Пример4
VALUES
(@N, @T, DATEADD(DAY, 6, @T))
SET @T = DATEADD(DAY, 7, @T)
SET @N = @N + 1
END
SELECT
[Номер недели]
,[Дата начала]
,[Дата конца]
FROM
@Пример4
```

---

### [Временные таблицы](https://metanit.com/sql/sqlserver/10.4.php)

В MS SQL Server для хранения промежуточных данных можно использовать временные таблицы. 
Они по поведению не отличаются от базовых таблиц. Создание, удаление и обращение к ним аналогично к базовым.
Первый символ в названии временной таблицы должен быть знак решетки #. 
Для локальных временных таблиц используется один знак #.
Локальные временные таблицы доступны в течение текущей сессии и удаляются, когда пользователь отсоединяется от сервера.
Для глобальных временных таблиц используются два знака ##. 

Глобальные временные таблицы доступны всем открытым сессиям базы данных и удаляются, когда все пользователи,
ссылающиеся на таблицы, отсоединяются от сервера.

Временные таблицы хранятся в системной базе данных TEMPDB.

Для принудительного удаления временных таблиц используется команда DROP TABLE.

Пример: Создайте локальную временную таблицу, имеющую три столбца 
(«Название месяца», «Количество экзаменов», «Количество студентов»), заполните и используйте ее:
```sql
SELECT
DATENAME(MONTH, Дата) AS [Название месяца]
, COUNT(DISTINCT Код) AS [Количество экзаменов]
, COUNT(DISTINCT Рег_номер) AS [Количество студентов]
INTO
#Пример6
FROM
Экзамен
GROUP BY
DATENAME(MONTH, Дата)
SELECT * FROM #Пример6
```
---

### [Производные таблицы / Обобщенные табличные выражения](https://metanit.com/sql/sqlserver/10.4.php)

В MS SQL Server можно создать временно именованный результирующий набор, называемый обобщенным табличным выражением. 

Он формируется при выполнении простого запроса.

За обобщенным табличным выражением должны следовать одиночные инструкции
SELECT, INSERT, UPDATE или DELETE, ссылающиеся на некоторые или на все столбцы.
Обобщенные табличные выражения хранятся в оперативной памяти и существуют
только во время первого выполнения запроса, который представляет эту таблицу.

Обобщенное табличное выражение задается с помощью ключевого слова WITH:
```sql
WITH OrdersInfo AS
(
    SELECT ProductId, 
        SUM(ProductCount) AS TotalCount, 
        SUM(ProductCount * Price) AS TotalSum
    FROM Orders
    GROUP BY ProductId
)
 
SELECT * FROM OrdersInfo -- здесь нормально
SELECT * FROM OrdersInfo -- здесь ошибка
SELECT * FROM OrdersInfo -- здесь ошибка
```

---

### Пользовательские функции

На языке Transact-SQL очень много встроенных функций. 
Несмотря на этот факт, иногда требуются функции, которых нет в стандартной библиотеке.
Transact-SQL предоставляет возможность создать собственную функцию для решения задач.

#### Скалярные функции

Пользовательская скалярная функция возвращает в качестве ответа единственное значение.

Пользовательскую функцию можно использовать следующими способами:

* В инструкциях Transact-SQL, например, SELECT.
* В приложениях, вызывающих функцию.
* В определении другой пользовательской функции.
* Для определения столбца таблицы.
* Для определения ограничения CHECK на столбец.

Пользовательские функции не могут выполнять действия, изменяющие состояние базы данных.
Пользовательские функции не могут возвращать несколько результирующих наборов.
Пользовательские функции не могут использовать динамический SQL и временные таблицы.

Табличные переменные разрешены к использованию.

Пользовательские функции могут быть вложенными, то есть из одной функции может быть вызвана другая.
Вложенность функций не может превышать 32 уровней.

Упрощенный синтаксис создания пользовательской скалярной функции имеет следующий вид:

```sql
CREATE FUNCTION <название>
(
[{<@параметр> [AS] <тип> [= <значение по умолчанию>]}]
)
RETURNS <тип возврата>
[AS]
BEGIN
<команды>
RETURN <значение>
END
```
Значение, переменная или выражение после ключевого слова RETURN имеет такой же тип, 
который указан после ключевого слова RETURNS.

Если функция не предполагает передачу параметров, то в скобках ничего не укзаывается:
```sql
CREATE FUNCTION <название>()
RETURNS <тип возврата>
[AS]
<тело функции>
```

#### Функции INLINE

Для INLINE функций ключевого слова RETURNS указывается тип TABLE без указания списка столбцов. 

Тело такой функции представляет собой единственный оператор SELECT,
который начинается сразу после ключевого слово RETURN.

Упрощенный синтаксис создания пользовательской функции INLINE имеет следующий вид:

```sql
CREATE FUNCTION <название>
(
[{<@параметр> [AS] <тип> [= <значение по умолчанию>]}]
)
RETURNS TABLE
AS
RETURN
(
SELECT
<список столбцов>
FROM
<таблица>
WHERE
<условие>
)
```

#### Функции MULTI-STATEMENT

В MULTI-STATEMENT функциях после ключевого слова RETURNS указывается тип TABLE с определением столбцов и их типов данных.
Упрощенный синтаксис создания пользовательской MULTI-STATEMENT функции имеет следующий вид:

```sql
CREATE FUNCTION <название>
(
[{<@параметр> [AS] <тип> [= <значение по умолчанию>]}]
)
RETURNS <@таблица> TABLE (<определение таблицы>)
AS
BEGIN
<команды>
RETURN
END
```
Для MULTI-STATEMENT функций оператор RETURN не имеет аргумента.
Значение возвращаемой переменной функции возвращается как значение функции.

Пример:

```sql
CREATE FUNCTION dbo.UdfGetProductsScrapStatus
(
@ScrapComLevel INT
) 
RETURNS @ResultTable TABLE
( 
ProductName VARCHAR(50), ScrapQty FLOAT, ScrapReasonDef VARCHAR(100), ScrapStatus VARCHAR(50)
) AS BEGIN
        INSERT INTO @ResultTable
            SELECT PR.Name, SUM([ScrappedQty]), SC.Name, NULL
                FROM [Production].[WorkOrder] AS WO
                        INNER JOIN 
                        Production.Product AS PR
                        ON Pr.ProductID = WO.ProductID
                        INNER JOIN Production.ScrapReason AS SC
                        ON SC.ScrapReasonID = WO.ScrapReasonID
                WHERE WO.ScrapReasonID IS NOT NULL
                GROUP BY PR.Name, SC.Name
UPDATE @ResultTable
            SET ScrapStatus = 
            CASE WHEN ScrapQty > @ScrapComLevel THEN 'Critical'
            ELSE 'Normal'
            END
        
RETURN
END
```

#### Удаление пользовательских функций

Для удаления пользовательских функций используется команда DROP FUNCTION.

Упрощенный синтаксис имеет следующий вид:

```sql
DROP FUNCTION [IF EXISTS] <название функции>
```

Ключевые слова IF EXISTS удаляют функцию только в том случае, если она уже существует.

#### Вызов пользовательских функций

Созданная функция может быть вызвана, как и обычная встроенная функция, но при этом должны вызываться с помощью имени владельца.

Простой вызов имеет следующий вид: 
```sql
SELECT <владелец>.<функция>(<параметры>)
```

Функция может быть вызвана внутри запроса для каждого значения какого-либо из столбцов.

Пример:
```sql
SELECT
<владелец>.<функция>(<столбец>) [ AS Новое название столбца]
<список других необходимых для запроса столбцов>
FROM
<таблица>
```

Для пользовательских функций допускается не более 2100 параметров. 
При выполнении функции значение каждого из объявленных параметров должно быть указано пользователем, 
если для них не определены значения по умолчанию.

Имя параметра, как и имя переменных, использует знак @ как первый символ.

Вызов функций, возвращающих табличное значение имеет вид:

```sql
SELECT * FROM <владелец>.<функция>(<параметры>)
```

Вызов функции с дефолтным значением параметра (которое было указано по умолчанию при объявлении параметров):

```sql
SELECT <владелец>.<функция>(DEFAULT) AS [Название столбца]
```

Если в функцию не передаются параметры, то при вызове в скобках ничего не указывается:

```sql
SELECT * FROM <владелец>.<функция>()
```

---
