---
title: Лабораторная работа 10. Индексы и ограничения
---

[Вариант 2](assets/lab/v2.md)

[Таблица академиков](assets/lab2/Академики.xlsx)

[Таблицы студентов](assets/lab6/Students.xlsx)

[К списку лабораторных >>>](../README.md)

---

### Задания по таблицам из демо-экзамена

Через "ALTER TABLE имя_таблицы ADD CONSTRAINT ..." добавить ограничения для столбцов, согласно ТЗ ([вариант 2](assets/lab/v2.md), примерный список):

1. Поля: идентификатор, дата добавления, дата посещения - генерируются автоматически и являются неизменяемыми.
2. Поля фамилии, имени и отчества не могут быть длиннее 50 символов.
3. Поле телефона может содержать только цифры и следующие символы: плюс, минус, открывающая и закрывающая круглые скобки, знак пробела.
4. Размер фотографии не должен превышать 2 мегабайта (т.е. мы работаем с PhotoPath, то ввести ограничение на длину строки с путём к файлу).
5. Попробовать задать варианты значений для именования пола в таблице с полами через команду CHECK.
6. Указать уникальность телефона и email, чтобы исключить возможность заводить клиентов с одинаковыми контактными данными
  (такое может не сработать для случая родитель-ребенок, но в большинстве других это имеет смысл).
7. Написать скрипты для добавления записей с корректными и некорректными данными. Можно реализовать обработку ошибок через try-catch.

---

### Задания на индексы по таблице академиков

1. Создать первичный ключ на поле "ФИО", сделав индекс этого ограничения некластерным.
2. Создать кластерный индекс по столбцу с уникальными значениями "Дата рождения".
3. Создать самостоятельный некластерный индекс для поля "Дата присвоения звания", выбрав сортировку по убыванию.
4. Написать скрипт для реорганизации индекса по полю "ФИО".
5. Сделать реорганизацию всех индексов в таблице.
6. Написать скрипт для перестроения индекса по полю "Дата рождения".
7. Сделать перестроение всех индексов в таблице.
8. Вывести все индексы таблицы и их типы.  
9. Удалить самостоятельный индекс.
10. Удалить индекс, добавленный через ограничение.

---

### Задания на индексированные представления по таблицам студентов

1. Предварительно создать схему таблиц, по которой будем создавать индексированные представления (таблицы потом создавать внутри этой схемы)
2. Создать индексированное представление с название дисциплины, фамилию, должность и степень преподавателя, месяц и место проведения экзаменов. Уникальный Кластерный индекс использовать для поля "Фамилия".
3. Создать некластерные индексы для полей "Месяц" и "Место"
4. Удалить однозначный кластеризованный индекс в индексированном представлении
5. Создать обычное представление со столбцами «Кафедра», «Специальность» и «Сотрудник» данными о выпускающих кафедрах (факультет, шифр, название, фамилию заведующего). Выпускающей считается та кафедра, на которую есть ссылки в таблице «Специальность».
6. Изменить предыдущее представление на индексированное.
7. Узнать, материализовано ли представление (использует ли оно дисковое пространство, а индексы обычно его используют)
8. Проверить, активирован ли какой-либо параметр инструкции SET (??? зачем ???)

---

### Ограничения

```sql
ALTER TABLE имя_таблицы ADD перечень_полей_с_характеристиками 
```
– позволяет добавить новые поля в таблицу;

```sql
ALTER TABLE имя_таблицы DROP COLUMN перечень_полей 
```
– позволяет удалить поля из таблицы;

```sql
ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения 
FOREIGN KEY(поля) REFERENCES таблица_справочник(поля) 
```
– позволяет определить связь между таблицей и таблицей справочником

Добавление свойства IDENTITY к полю 
– позволяет сделать это поле автоматически заполняемым (полем-счетчиком) для таблицы;

Все виды ограничений, которые создаются командой вида 
```sql
ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения
```

PRIMARY KEY – первичный ключ;
FOREIGN KEY – настройка связей и контроль ссылочной целостности данных;
UNIQUE – позволяет создать уникальность;
CHECK – позволяет осуществлять корректность введенных данных;
DEFAULT – позволяет задать значение по умолчанию;

Все ограничения можно удалить, используя команду вида
```sql
ALTER TABLE имя_таблицы DROP CONSTRAINT имя_ограничения
```
---

### Прочие ограничения (UNIQUE, DEFAULT, CHECK)

#### UNIQUE

При помощи ограничения UNIQUE можно сказать, что значения для каждой строки в данном поле или в наборе полей должно быть уникальным.

```sql
CREATE TABLE Production.TransactionHistoryArchive4  
 (  
   TransactionID int NOT NULL,   
   CONSTRAINT AK_TransactionID UNIQUE(TransactionID)   
)

ALTER TABLE Employees ADD CONSTRAINT UQ_Employees_Email UNIQUE(Email)

ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения UNIQUE(поле1,поле2,…)
```

#### DEFAULT

При помощи добавления к полю ограничения DEFAULT мы можем задать значение по умолчанию, 
которое будет подставляться в случае, если при вставке новой записи данное поле не будет перечислено в списке полей команды INSERT.

```sql
ALTER TABLE Employees ADD HireDate date NOT NULL DEFAULT SYSDATETIME()

ALTER TABLE Employees ADD DEFAULT SYSDATETIME() FOR HireDate

ALTER TABLE Employees ADD CONSTRAINT DF_Employees_HireDate DEFAULT SYSDATETIME() FOR HireDate
```

#### CHECK

Проверочное ограничение CHECK используется в том случае, когда необходимо осуществить проверку вставляемых в поле значений. 
Например, наложим данное ограничение на поле табельный номер, которое у нас является идентификатором сотрудника (ID). 
При помощи данного ограничения скажем, что табельные номера должны иметь значение от 1000 до 1999:

```sql
ALTER TABLE Employees ADD CONSTRAINT CK_Employees_ID CHECK(ID BETWEEN 1000 AND 1999)
```

Можно так же создать ограничения UNIQUE и CHECK без указания имени:

```sql
ALTER TABLE Employees ADD UNIQUE(Email) ALTER TABLE Employees 
ADD CHECK(ID BETWEEN 1000 AND 1999)
```

Мы можем также использовать ограничение CHECK чтобы защитить от ввода в поле определенных значений, и таким образом предотвратить ошибку. 
Например, предположим, что единствеными городами в которых мы имели ведомства сбыта являются Лондон, Барселона, Сан Хосе, и Нью Йорк. 
Если вам известны все продавцы, работающие в каждом из этих ведомств, нет необходимости позволять ввод других значений. 
Если же нет, использование ограничения может предотвратить опечатки и другие ошибки.

```sql
CREATE TABLE Salespeople
(snum integer NOT NULL UNIQUE,
sname char(10) NOT NULL UNIQUE,
city char(10)
CHECK (city IN ('London', 'New York', 'San Jose', 'Barselona')),
comm decimal CHECK (comm<1));
```

Вы можете также использовать CHECK в качестве табличного ограничения. 
Это полезно в тех случаях, когда вы хотите включить более одного поля строки в условие.
Предположим, что комиссионные .15 и выше будут разрешены только для продавца из Барселоны. 

Вы можете указать это со следующим табличным ограничением CHECK:
```sql
CREATE TABLE Salespeople
(snum integer NOT NULL UNIQUE,
sname char (10) NOT NULL UNIQUE,
city char(10),
comm decimal,
CHECK (comm < .15 OR city = 'Barcelona'))
```

#### [Просмотр списка всех ограничений](https://sky.pro/wiki/sql/sql-server-2008-kak-poluchit-ogranicheniya-vsekh-tablits/)

Просмотреть, какие ограничения созданы в отдельно взятой таблице, можно следующим запросом:

```sql
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE
FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS
WHERE TABLE_NAME = 'YourTable';
```

---

### ON DELETE и ON UPDATE

Напоследок стоит сказать, что ссылочные ключи могут включать дополнительные опции 
ON DELETE CASCADE и ON UPDATE CASCADE, которые говорят о том, как вести себя при удалении или обновлении записи, 
на которую есть ссылки в таблице-справочнике. 

Если эти опции не указаны, то мы не можем изменить ID в таблице справочнике у той записи, 
на которую есть ссылки из другой таблицы, так же мы не сможем удалить такую запись из справочника, 
пока не удалим все строки, ссылающиеся на эту запись или, же обновим в этих строках ссылки на другое значение.

И для определения действия мы можем использовать следующие опции:

* NO ACTION: предотвращает какие-либо действия в зависимой таблице при удалении или изменении связанных строк в главной таблице.
  То есть фактически какие-либо действия отсутствуют.

* CASCADE: автоматически удаляет или изменяет строки из зависимой таблицы при удалении или изменении связанных строк в главной таблице.

* SET NULL: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL.

* SET DEFAULT: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение по умолчанию,
  которое задается с помощью атрибуты DEFAULT. Если для столбца не задано значение по умолчанию,
  то в качестве него применяется значение NULL.

#### CASCADE

Для примера пересоздадим таблицу с указанием опции ON DELETE CASCADE для FK_Employees_DepartmentID:
```sql
DROP TABLE Employees

CREATE TABLE Employees(
  ID int NOT NULL,
  Name nvarchar(30),
  Birthday date,
  Email nvarchar(30),
  PositionID int,
  DepartmentID int,
  ManagerID int,
CONSTRAINT PK_Employees PRIMARY KEY (ID), 
CONSTRAINT FK_Employees_DepartmentID
  FOREIGN KEY(DepartmentID)
  REFERENCES Departments(ID)
  ON DELETE CASCADE, 
CONSTRAINT FK_Employees_PositionID
  FOREIGN KEY(PositionID)
  REFERENCES Positions(ID),
CONSTRAINT FK_Employees_ManagerID
  FOREIGN KEY (ManagerID)
  REFERENCES Employees(ID)
)
INSERT Employees (ID,Name,Birthday,PositionID,DepartmentID,ManagerID)VALUES
(1000,N'Иванов И.И.','19550219',2,1,NULL),
(1001,N'Петров П.П.','19831203',3,3,1003),
(1002,N'Сидоров С.С.','19760607',1,2,1000),
(1003,N'Андреев А.А.','19820417',4,3,1000)
```

Удалим отдел с идентификатором 3 из таблицы Departments:
```sql
DELETE Departments WHERE ID=3
```

Посмотрим на данные таблицы Employees:
```sql
SELECT * FROM Employees
```
Как видим, данные по отделу 3 из таблицы Employees так же удалились.

Опция ON UPDATE CASCADE ведет себя аналогично, но действует она при обновлении значения ID в справочнике (в нашем примере). 
То есть, при изменении значения первичного ключа автоматически изменится значение связанного с ним внешнего ключа. 
Но так как первичные ключи, как правило, изменяются очень редко, 
да и с принципе не рекомендуется использовать в качестве первичных ключей столбцы с изменяемыми значениями, то на практике выражение ON UPDATE используется редко.

Например, если мы поменяем ID должности в справочнике должностей, 
то в этом случае будет производиться обновление DepartmentID в таблице Employees 
на новое значение ID которое мы задали в справочнике. 

Но в данном случае это продемонстрировать просто не получится, 
т.к. у колонки ID в таблице Departments стоит опция IDENTITY, 
которая не позволит нам выполнить следующий запрос (сменить идентификатор отдела 3 на 30):
```sql
UPDATE Departments
SET ID=30
WHERE ID=3
```

Главное понять суть этих 2-х опций ON DELETE CASCADE и ON UPDATE CASCADE,
применять эти опции очень в редких случаях и хорошо подумать, 
прежде чем указывать их в ссылочном ограничении, 
т.к. при нечаянном удалении записи из таблицы справочника это может привести к большим проблемам и создать цепную реакцию.

#### Установка NULL
При установки для внешнего ключа опции SET NULL необходимо, чтобы столбец внешнего ключа допускал значение NULL:

```sql
CREATE TABLE Orders
(
    Id INT PRIMARY KEY IDENTITY,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET NULL
);
```

#### Установка значения по умолчанию

```sql
CREATE TABLE Orders
(
    Id INT PRIMARY KEY IDENTITY,
    CustomerId INT,
    CreatedAt Date,
    FOREIGN KEY (CustomerId) REFERENCES Customers (Id) ON DELETE SET DEFAULT
)
```

---


### [Индексы](https://learn.microsoft.com/ru-ru/sql/relational-databases/indexes/clustered-and-nonclustered-indexes-described?view=sql-server-ver16)

Одним из важнейших путей достижения высокой производительности SQL Server является использование индексов. 
Индекс ускоряет процесс запроса, предоставляя быстрый доступ к строкам данных в таблице, аналогично тому, 
как указатель в книге помогает вам быстро найти необходимую информацию. 

Индексы создаются для столбцов таблиц и представлений. 
Индексы предоставляют путь для быстрого поиска данных на основе значений в этих столбцах. 
Например, если вы создадите индекс по первичному ключу, а затем будете искать строку с данными,
используя значения первичного ключа, то SQL Server сначала найдет значение индекса, 
а затем использует индекс для быстрого нахождения всей строки с данными. 
Без индекса будет выполнен полный просмотр (сканирование) всех строк таблицы, что может оказать значительное влияние на производительность.

Вы можете создать индекс на большинстве столбцов таблицы или представления. 
Исключением, преимущественно, являются столбцы с типами данных для хранения больших объектов (LOB), 
таких как image, text или varchar(max). Вы также можете создать индексы на столбцах, 
предназначенных для хранения данных в формате XML, но эти индексы устроены немного иначе, чем стандартные.

### [Кластерные (CLUSTERED) индексы](https://learn.microsoft.com/ru-ru/sql/relational-databases/indexes/create-clustered-indexes?view=sql-server-ver16)

По умолчанию индекс для первичного ключа создается как CLUSTERED, а для всех остальных индексов как NONCLUSTERED. 

Стоит сказать, что понятие кластерного индекса есть не во всех СУБД. Таблица может иметь только один кластерный (CLUSTERED) индекс.

CLUSTERED – означает, что записи таблицы будут сортироваться по этому индексу, так же можно сказать, 
что этот индекс имеет непосредственный доступ ко всем данным таблицы. 
Это так сказать главный индекс таблицы. 
Если сказать еще грубее, то это индекс, прикрученный к таблице. 

Кластерный индекс – это очень мощное средство, которое может помочь при оптимизации запросов.

Кластеризованные индексы реализуются следующими методами:

* Ограничениями PRIMARY KEY и UNIQUE - сли кластеризованный индекс в таблице еще не создан,
  а уникальный некластеризованный индекс еще не указан, то при создании ограничения PRIMARY KEY
  в одном или нескольких столбцах автоматически создается уникальный кластеризованный индекс.
  В первичном ключевом столбце недопустимы значения NULL.

* При создании ограничения UNIQUE создается уникальный некластеризованный индекс.
  Он нужен, чтобы принудительно применять ограничение UNIQUE по умолчанию.
  Если кластеризованный индекс в таблице еще не создан, то можно указать уникальный кластеризованный индекс.

Индексу, создаваемому в составе ограничения, автоматически присваивается то же имя, что и имя ограничения.

### Индекс, не зависящий от ограничения

Можно создать кластеризованный индекс в столбце, отличном от первичного ключевого столбца, если задано ограничение некластеризованного первичного ключа.

Индексы могут быть созданы как для одного атрибута (простые индексы), так и для совокупности атрибутов(составные индексы).
К индексам может быть предъявлено требование уникальности, что означает невозможность существования нескольких записей с одинаковыми значениями индекса.

Кластерные индексы – принципиальным отличие кластерного индекса является то, что при его определении
физическое расположение записей таблицы изменяется в соответствии со структурой индекса, 
т.е. записи в таблице упорядочиваются в соответствии со значением индекса. 
При некластерном индексе каждая новая запись добавляется в конец таблицы, 
а при кластерной записи перемещаются таким образом, что новая помещается в то место, 
которое определяется по значению соответствующего ей индекса. 

Кластерные индексы дают существенное увеличение производительности, 
особенно при работе с совокупностью последовательных записей (идущих одна за другой).

Необходимо избегать создания кластерного индекса для часто изменяемых столбцов (атрибутов), 
поскольку сервер должен будет выполнять физическое перемещение записей таблицы, 
чтобы они находились в упорядоченном состоянии, соответствующем кластерному индексу.

! При создании PRIMARY KEY сервер автоматически создает для него кластерный индекс.

### [Некластерные (NONCLUSTERED) индексы](https://learn.microsoft.com/ru-ru/sql/relational-databases/indexes/create-nonclustered-indexes?view=sql-server-ver16)

Некластерные индексы - наиболее типичный вид индексов. Они не перестраивают физическую структуру таблицы,
а лишь организуют ссылки, определяющие по значению индекса адреса соответствующих записей.
Если в таблице в дополнение к кластерному индексу создан еще и некластерный индекс, 
то указатель в некластерном индексе ссылается не на физическое положение строки, 
а на соответствующий элемент кластерного индекса, описывающего эту строку, 
что позволяет не перестраивать структуру некластерных индексов каждый раз, 
когда кластерный индекс меняет физический порядок строк в таблице.

Некластеризованные индексы реализуются следующим образом:

* Ограничения UNIQUE - при создании ограничения UNIQUE создается уникальный некластеризованный индекс.
  Он нужен, чтобы принудительно применять ограничение UNIQUE по умолчанию.
  Если кластеризованный индекс в таблице еще не создан, то можно указать уникальный кластеризованный индекс.
  Дополнительные сведения см. в статье Ограничения уникальности и проверочные ограничения.

* Индекс, не зависящий от ограничения - по умолчанию некластеризованный индекс создается в том случае,
  если ранее не был задан кластеризованный индекс. Для таблицы может быть создано не более 999 некластеризованных индексов.
  В это число входят любые индексы, созданные ограничениями PRIMARY KEY или UNIQUE, но не входят XML-индексы.

* Некластеризованный индекс в индексированном представлении - некластеризованные индексы в представлении
  могут создаваться только после создания в нем уникального кластеризованного индекса.

SQL Server 2005 поддерживает до 249 некластеризованных индексов и SQL Server 2008 поддерживает до 999.

Если мы хотим сказать, чтобы кластерный индекс использовался не в первичном ключе, 
а для другого индекса, то при создании первичного ключа мы должны указать опцию NONCLUSTERED:
```sql
ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения PRIMARY KEY NONCLUSTERED(поле1,поле2,…)
```

Для примера сделаем индекс ограничения PK_Employees некластерным, а индекс ограничения UQ_Employees_Email кластерным. 
 Первым делом удалим данные ограничения:
```sql
ALTER TABLE Employees DROP CONSTRAINT PK_Employees
ALTER TABLE Employees DROP CONSTRAINT UQ_Employees_Email
```

### Добавление кластерных и некластерных индексов.

А теперь создадим их с опциями CLUSTERED и NONCLUSTERED:
```sql
ALTER TABLE Employees ADD CONSTRAINT PK_Employees PRIMARY KEY NONCLUSTERED (ID)
ALTER TABLE Employees ADD CONSTRAINT UQ_Employees_Email UNIQUE CLUSTERED (Email)
```

### Создание самостоятельных индексов.

Под самостоятельностью здесь имеются в виду индексы, которые создаются не для ограничения PRIMARY KEY или UNIQUE.

Индексы по полю или полям можно создавать следующей командой:
```sql
CREATE INDEX IDX_Employees_Name ON Employees(Name)
```

Так же можно указать опции CLUSTERED, NONCLUSTERED, UNIQUE, 
а так же можно указать направление сортировки каждого отдельного поля ASC (по умолчанию) или DESC:

```sql
CREATE UNIQUE NONCLUSTERED INDEX UQ_Employees_EmailDesc ON Employees(Email DESC)
```

При создании некластерного индекса опцию NONCLUSTERED можно отпустить, 
т.к. она подразумевается по умолчанию, здесь она показана просто, 
чтобы указать позицию опции CLUSTERED или NONCLUSTERED в команде.

Простые индексы так же, как и ограничения, можно создать в контексте команды CREATE TABLE.

Создание таблицы со всеми созданными ограничениями и индексами одной командой CREATE TABLE:
```sql
CREATE TABLE Employees(
  ID int NOT NULL,
  Name nvarchar(30),
  Birthday date,
  Email nvarchar(30),
  PositionID int,
  DepartmentID int,
  HireDate date NOT NULL CONSTRAINT DF_Employees_HireDate DEFAULT SYSDATETIME(),
  ManagerID int,
CONSTRAINT PK_Employees PRIMARY KEY (ID), 
CONSTRAINT FK_Employees_DepartmentID FOREIGN KEY(DepartmentID) REFERENCES Departments(ID), 
CONSTRAINT FK_Employees_PositionID FOREIGN KEY(PositionID) REFERENCES Positions(ID), 
CONSTRAINT FK_Employees_ManagerID FOREIGN KEY (ManagerID) REFERENCES Employees(ID), 
CONSTRAINT UQ_Employees_Email UNIQUE(Email), 
CONSTRAINT CK_Employees_ID CHECK(ID BETWEEN 1000 AND 1999), 
INDEX IDX_Employees_Name(Name)
)
```

В итоге:

Индексы могут повысить скорость выборки данных (SELECT), но индексы уменьшают скорость модификации данных таблицы, 
т.к. после каждой модификации системе будет необходимо перестроить все индексы для конкретной таблицы.

---

### [Удаление индексов](https://learn.microsoft.com/ru-ru/sql/relational-databases/indexes/delete-an-index?view=sql-server-ver16)

Удалить индекс можно следующей командой:
```sql
DROP INDEX IDX_Employees_Name ON Employees
```
---

### [Изменение индекса](https://learn.microsoft.com/ru-ru/sql/relational-databases/indexes/modify-an-index?view=sql-server-ver16)

Индексы, созданные в результате применения ограничения PRIMARY KEY или UNIQUE, изменить этим способом нельзя. 
Вместо этого необходимо изменить само ограничение.

В следующем примере с помощью инструкции ALTER INDEX задаются несколько параметров для индекса AK_SalesOrderHeader_SalesOrderNumber.
```sql
ALTER INDEX AK_SalesOrderHeader_SalesOrderNumber ON
    Sales.SalesOrderHeader
SET (
    STATISTICS_NORECOMPUTE = ON,
    IGNORE_DUP_KEY = ON,
    ALLOW_PAGE_LOCKS = ON
    )
;
```

Чтобы добавить, удалить или изменить позицию столбца индекса, необходимо удалить и повторно создать индекс.

---

### [Просмотр созданных индексов](https://learn.microsoft.com/ru-ru/sql/relational-databases/system-stored-procedures/sp-helpindex-transact-sql?view=sql-server-ver16)

В следующем примере сообщаются данные о типах индексов в таблице.
```sql
USE <имя_базы>;  
GO  
EXEC sp_helpindex <имя_таблицы>;  
GO  
```

---

### [Реорганизация и перестроение индексов](https://learn.microsoft.com/ru-ru/sql/relational-databases/indexes/reorganize-and-rebuild-indexes?view=sql-server-ver16)

Реорганизация индекса требует меньше ресурсов, чем его перестроение. Поэтому следует считать ее предпочтительным методом для обслуживания индекса, 
если нет веских причин использовать перестроение индекса. Реорганизация всегда выполняется с сохранением подключения. 
Это означает, что не создаются долгосрочные блокировки таблиц и запросы или обновления базовой таблицы во время выполнения операции ALTER INDEX ... REORGANIZE могут продолжаться.

При перестроении старый индекс удаляется, и создается новый.
В зависимости от типа индекса и версии ядра СУБД операция перестроения может выполняться в подключенном или автономном режиме. 
Перестроение индекса в автономном режиме обычно занимает меньше времени, чем с сохранением подключения, 
но при этом используются блокировки на уровне объектов на весь период операции перестроения, то есть запросы к таблице или представлению не выполняются.

Перестроение индекса с сохранением подключения не требует блокировок на уровне объектов до окончания операции, 
если есть возможность устанавливать блокировку на короткий период для выполнения перестроения. 
В зависимости от версии ядра СУБД перестроение индекса с сохранением подключения может запускаться как возобновляемая операция. 
Возобновляемое перестроение индекса можно приостановить, сохраняя ход выполнения до текущего момента.
Операцию возобновляемого перестроения можно возобновить после приостановки или другого прерывания. 
Кроме того, ее можно отменить, если завершение перестроения больше не требуется.

#### Реорганизация индекса
В приведенном ниже примере показано, как реорганизовать индекс IX_Employee_OrganizationalLevel_OrganizationalNode 
в таблице HumanResources.Employee базы данных AdventureWorks2022.

```sql
ALTER INDEX IX_Employee_OrganizationalLevel_OrganizationalNode
    ON HumanResources.Employee
    REORGANIZE;
```

Пример, как реорганизовать индекс columnstore IndFactResellerSalesXL_CCI 
в таблице dbo.FactResellerSalesXL_CCI базы данных AdventureWorksDW2022. 
Эта команда заставляет все закрытые и открытые группы строк в columnstore.

```sql
-- This command forces all closed and open row groups into columnstore.
ALTER INDEX IndFactResellerSalesXL_CCI
    ON FactResellerSalesXL_CCI
    REORGANIZE WITH (COMPRESS_ALL_ROW_GROUPS = ON);
```

#### Реорганизация всех индексов в таблице

Пример, как реорганизовать все индексы в таблице HumanResources.Employee базы данных AdventureWorks2022.

```sql
ALTER INDEX ALL ON HumanResources.Employee
   REORGANIZE;
```

#### Перестроение индекса

Пример, как перестроить единственный индекс на таблице Employee базы данных AdventureWorks2022.

```sql
ALTER INDEX PK_Employee_BusinessEntityID ON HumanResources.Employee
REBUILD
;
```

#### Перестроение всех индексов в таблице

Пример, как перестроить все индексы, связанные с таблицей базы данных AdventureWorks2022, 
используя ключевое слово ALL. Указываются три параметра.

```sql
ALTER INDEX ALL ON Production.Product
REBUILD WITH (FILLFACTOR = 80, SORT_IN_TEMPDB = ON,
              STATISTICS_NORECOMPUTE = ON)
;
```

---

### Для каких полей следует создавать индексы

Объявление ненужных ключей (индексов) только займет дополнительное место и замедлит выполнение запроса. 
Поэтому следует продумать вопрос для каких полей имеет смысл создавать индексы. 
Следует создавать индексы для полей, по которым часто выполняется поиск (выборки), сортировка, соединение таблиц. 
Для остальных полей индексы создавать не стоит, это займет дополнительное место и замедлит выполнение запросов,
т.к. при добавлении, обновлении, удалении данных индексы так же обновляются.
Следует помнить, что индексация столбца требует дополнительного объема памяти для хранения индекса, 
иногда превышающего объем основных данных в несколько раз,
и приводит к замедлению операций вставки и удаления с помощью команд INSERT и DELETE. 

При создании индексов следует руководствоваться следующими простыми правилами:

*	Практически все таблицы должны иметь первичный ключ, который строится на индексе, 
  особенно если этот ключ часто используется. Для полей первичного и внешнего ключей создаются системные индексы.
*	Небольшие  таблицы (меньше 100 строк) не нуждаются в индексах.
  Процесс индексации такой таблицы достаточно быстр, так что получается достаточно высокая производительность без создания индекса.
*	Стоит индексировать поля, которые часто используется в запросах, и не стоит индексировать столбцы, которые используются редко.
*	Любое поле, используемое в агрегирующей функции (сумма, агрегат и т.д.),
  которая содержит предложения GROUP BY или ORDER BY и используется в JOIN,
 	должно рассматриваться как кандидат на индекс. Дело в том, что ядро СУБД для этих операций использует индексы.
*	Хорошая практика не индексировать поля, в которых данные постоянно изменяются.
  Индекс требует дополнительного дискового пространства, будет сильно фрагментирован,
 	а операции вставки, изменения и переиндексации будут требовать больших затрат системных ресурсов, чего мы хотим избежать.
*	Также, избегайте индексирования длинных полей данных.
*	Индексируйте любой столбец, который имеет большое количество уникальных значений и часто используется в запросах.


---

### [Индексированные представления](https://learn.microsoft.com/ru-ru/sql/relational-databases/views/create-indexed-views?view=sql-server-ver16)

В представлении так же можно создавать индексы.

Первым индексом, создаваемым для представления, должен быть уникальный кластеризованный индекс.

После создания уникального кластеризованного индекса могут быть созданы некластеризованные индексы. 
Создание уникального кластеризованного индекса в представлении повышает производительность запросов, 
так как представление хранится в базе данных таким же образом, как таблица с кластеризованным индексом сохраняется. 
Оптимизатор запросов может использовать индексированные представления для ускорения выполнения запросов. 
Представление не должно ссылаться в запросе оптимизатора, чтобы рассмотреть это представление для подстановки.

Определение представления всегда содержит запрос, играющий роль фильтра.
Если представление не имеет индексов, то компонент Database Engine динамически создает
результирующий набор из всех запросов, которые обращаются к представлению. 
(Выражение "динамически" здесь означает, что модифицированное содержимое 
таблицы будет всегда отображаться в соответствующем представлении.) 
Кроме этого, если представление содержит вычисления по одному или 
больше столбцов таблицы, то эти вычисления выполняются при каждом обращении к представлению.

Если инструкция SELECT представления обрабатывает большое количество строк из одной или более таблиц,
динамическое создание результирующего набора запроса может понизить уровень производительности запроса.
Если подобное представление часто используется в запросах, уровень производительности можно значительно повысить,
создав кластеризованный индекс для этого представления.
Создание кластеризованного индекса означает, что система материализует динамические данные в страницах узлов структуры индекса.

Компонент Database Engine позволяет создавать индексы для представлений. 
Такие представления называются индексированными представлениями. 
Результирующий набор, возвращаемый представлением с кластеризованным индексом, 
сохраняется в базе данных таким же образом, как и таблица с кластеризованным индексом.
Это означает, что узлы листьев B+-дерева кластеризованного индекса содержат страницы данных.

Индексированные представления создаются посредством синтаксических расширений
инструкций CREATE INDEX и CREATE VIEW.
В инструкции CREATE INDEX вместо имени таблицы указывается имя представления.
Синтаксис инструкции CREATE VIEW расширяется предложением SCHEMABINDING.

---

### [Схема таблиц / SCHEMABINDING]( https://uchet-jkh.ru/i/cto-takoe-sxema-v-sql-i-kak-ona-rabotaet)

Одной из основных составляющих реляционной базы данных является схема, 
которая отвечает за описание структуры и отношений между данными. 
В терминах SQL (Structured Query Language) схема определяет сущности (таблицы), 
их атрибуты (столбцы) и связи между таблицами. 

Без схемы станет невозможным создавать и модифицировать базу данных, а также выполнять запросы и анализировать данные.

Структура схемы представляет собой набор таблиц, каждая из которых имеет 
уникальное имя и столбцы с определенными типами данных. 
Каждая таблица представляет собой отдельное отношение,
а строки этой таблицы представляют собой кортежи (записи), 
содержащие значения атрибутов. 
Благодаря применению ключей и внешних ключей можно создавать связи между таблицами и обеспечивать целостность данных.

Схема в SQL — это логическая структура, которая определяет организацию и отношения между таблицами в базе данных. 
Схема предоставляет возможность организовать данные в удобном для работы виде, определяет правила и ограничения для хранения и манипуляции данными.

В SQL существует несколько типов схем:

* Публичная схема — доступна для всех пользователей базы данных. В нее входят таблицы, предназначенные для публичного использования.
* Приватная схема — доступна только определенным пользователям или ролям. В нее входят таблицы с конфиденциальной информацией, которая требует специального доступа.

Создание и изменение схемы в SQL осуществляется с помощью оператора CREATE SCHEMA. Этот оператор позволяет определить название схемы, а также установить различные права доступа для пользователей.

При создании таблиц в SQL можно указать, к какой схеме они относятся. Это позволяет логически сгруппировать таблицы внутри схемы и облегчить работу с базой данных.

Особенностью схемы в SQL является то, что она позволяет организовывать данные вложенно. Внутри одной схемы могут быть определены другие схемы, что позволяет создавать более сложные структуры базы данных.

#### Встроенные схемы

Имеется четыре предопределенных встроенных схем, которые создаются, когда вы устанавливаете SQL Server:

* dbo

Схема по умолчанию. Предполагается, если не указано имя схемы. В запросах используется [ИмяТаблицы] или [ИмяСхемы].[ИмяТаблицы]

* guest

Владельцем является пользователь Guest (гость). Отключено по умолчанию. Если когда и используется, то редко.

* INFORMATION_SCHEMA

Схема для представлений метаданных SQL Server

* sys

Информация об объекте. Информация о выполняющемся запросе. Динамические административные представления (DMV) в памяти

#### Зачем использовать схемы?

* Гибкость в организации объектов баз данных
* Множество пользователей могут иметь разрешения на схему
* Пользователей можно удалять, не оказывая влияния на объекты или схемы
* Позволяют нескольким объектам иметь одинаковые имена, например, в хранилище данных с данными из нескольких источников данных с одинаковыми именами таблиц, схема добавляет уровень различия.

#### Использоване схем при создании представлений

Элементы схемы в SQL связываются между собой различными отношениями и зависимостями, 
что позволяет обеспечить целостность и структурированность данных.
Правильное проектирование схемы является важным шагом при создании базы данных и помогает обеспечить эффективность и безопасность её использования.

SCHEMABINDING – гарантирует наличие "связанных" объектов, 
нельзя будет изменить базовую таблицу или таблицы таким образом, что это может повлиять на определение представления.

Предложение SCHEMABINDING привязывает представление к схеме таблицы, по которой оно создается. 
Когда это предложение указывается, имена объектов баз данных в инструкции 
SELECT должны состоять из двух частей, т.е. в виде schema.db_object, 
где schema - владелец, а db_object может быть таблицей, представлением или определяемой пользователем функцией.

Любая попытка модифицировать структуру представлений или таблиц,
на которые ссылается созданное таким образом представление, будет неудачной. 
Чтобы такие таблицы или представления можно было модифицировать (инструкцией ALTER)
или удалять (инструкцией DROP), нужно удалить это представление или убрать из него предложение SCHEMABINDING.

#### Создание схемы с помощью Transact-SQL

Вот полный синтаксис T-SQL CREATE SCHEMA:

```sqlCREATE SCHEMA schema_name_clause [  [ ...n ] ]  
 ::=  
    {  
    schema_name  
    | AUTHORIZATION owner_name  
    | schema_name AUTHORIZATION owner_name  
    }  
 ::=   
    {   
        table_definition | view_definition | grant_statement |   
        revoke_statement | deny_statement   
    }
```

В следующем примере создается схема Chains, а затем таблица Sizes.

```sql
CREATE SCHEMA Chains;
GO
CREATE TABLE Chains.Sizes (ChainID int, width dec(10,2));
```

Дополнительные операции могут быть выполнены в рамках одной инструкции.
В следующем примере создается схема Sprockets , принадлежающая Joe таблице NineProngs.
Инструкция предоставляет разрешение SELECT для Bob и запрещает SELECT для John.

```sql
CREATE SCHEMA Sprockets AUTHORIZATION Joe  
    CREATE TABLE NineProngs (source int, cost int, partnumber int)  
    GRANT SELECT ON SCHEMA::Sprockets TO Bob  
    DENY SELECT ON SCHEMA::Sprockets TO John;  
GO  
```

Выполните следующую инструкцию, чтобы просмотреть схемы в текущей базе данных:

```sql
SELECT * FROM sys.schemas;
```

---

### [Создание индексированного представления](https://professorweb.ru/my/sql-server/2012/level3/3_8.php)

Индексированное представление создается в два этапа:

* Создается представление посредством инструкции CREATE VIEW с предложением SCHEMABINDING.
* Создается кластеризованный индекс для этого представления.

В примере ниже показан первый шаг создания индексированного представления
- создание представления.
- В этом примере предполагается, что таблица Works_on имеет очень большой размер.

```sql
USE SampleDb;

GO
CREATE VIEW view_enter_month
    WITH SCHEMABINDING
    AS SELECT EmpId, DATEPART(MONTH, EnterDate) AS EnterMonth
    FROM dbo.Works_on;
```

Таблица Works_on базы данных SampleDb содержит столбец EnterDate,
который представляет дату начала работы сотрудника над соответствующим проектом.
Всех сотрудников, которые начали работать над проектами в указанный месяц, 
можно выбрать с помощью представления, представленного в примере. 
Для выборки этого результирующего набора Database Engine не может использовать индекс таблицы, 
поскольку индекс для столбца EnterDate будет определять значения этого столбца по полной дате, 
а не только по месяцу. В таком случае можно воспользоваться индексированным представлением, 
создание которого показано в примере ниже:

```sql
USE SampleDb;

GO
CREATE UNIQUE CLUSTERED INDEX
    ix_work_deptnu ON view_enter_month (EnterMonth, EmpId);
```

Чтобы создать представление индексированным, необходимо создать однозначный (уникальный) 
кластеризованный индекс для столбца (столбцов) этого представления. 
(Как уже упоминалось ранее, кластеризованный индекс является единственным типом индекса, 
который содержит значения данных в своих страницах узлов.) 
После создания такого индекса система баз данных выделяет память для этого представления,
после чего можно создавать любое число некластеризованных индексов, 
поскольку теперь это представление рассматривается как (базовая) таблица.

Индексированное представление можно создать только в том случае, если оно является детерминированным,
т.е. представление всегда возвращает один и тот же результирующий набор. 
Для этого следующим параметрам инструкции SET нужно присвоить значение ON:

* QUOTED_IDENTIFIER
* CONCAT_NULL_YIELDS_NULL
* ANSI_NULLS
* ANSI_PADDING
* ANSI_WARNINGS

Кроме этого, параметру NUMERIC_ROUNDABORT нужно присвоить значение off.

Проверить, установлены ли должным образом параметры в предыдущем списке, 
можно несколькими способами, которые рассматриваются позже.
Чтобы создать индексированное представление, представление должно отвечать следующим требованиям:

* все используемые в представлении функции (как системные, так и определяемые пользователем)
  должны быть детерминированными, т.е. для одних и тех же аргументов они всегда должны возвращать один и тот же результат;

* представление должно ссылаться только на базовые таблицы;

* представление и ссылки на базовую таблицу (таблицы) должны иметь одного владельца и принадлежать к одной и той же базе данных;

* представление должно быть создано с опцией SCHEMABINDING.
  Эта опция связывает представление со схемой, содержащей базовые таблицы, лежащие в основе представления;

* определенные пользователем функции, на которые ссылается представление,
  должны быть созданы с предложением SCHEMABINDING;

* инструкция SELECT в представлении не должна содержать следующие предложения,
  параметры и прочие элементы: DISTINCT, UNION, TOP, ORDER BY, MIN, MAX, COUNT, OUTER, SUM
  (для выражений, допускающих значения NULL), подзапросы или производные таблицы.

Удовлетворение всех этих требований можно проверить посредством
функции свойств objectproperty с параметром свойств IsIndexable, как показано в примере ниже.
Если функция возвращает значение 1, то представление удовлетворяет всем требованиям для создания для него индекса:

```sql
USE SampleDb;

GO
SELECT objectproperty(
    object_id('view_enter_month'), 'IsIndexable'
);
```

---

### Модифицирование структуры индексированного представления

Чтобы удалить однозначный кластеризованный индекс в индексированном представлении, 
необходимо также удалить все его некластеризованные индексы. 
После удаления кластеризованного индекса представления система рассматривает его как обычное представление.
При удалении индексированного представления также удаляются все его индексы.

Если вы хотите изменить обычное представление на индексированное, 
то для него вам нужно создать кластеризованный индекс. Чтобы сделать это, 
вы сначала должны указать предложение SCHEMABINDING. Представление можно удалить,
а потом воссоздать, указав предложение SCHEMABINDING в инструкции CREATE SCHEMA, 
или же можно создать другое представление, которое имеет такой же текст, 
как и существующее представление, но имеет другое имя. При создании представления с другим именем необходимо обеспечить,
чтобы это представление отвечало всем требованиям для индексированных представлений, описанных в предшествующем разделе.

---

### Редактирование информации, связанной с индексированными представлениями

Проверить, активирован ли какой-либо параметр инструкции SET , можно с помощью функции свойств sessionproperty. 
Если функция возвращает значение 1, то указанный параметр установлен (т.е. имеет значение on).
В примере ниже показано использование этой функции для проверки значения параметра QUOTED_IDENTIFIER:

```sql
USE SampleDb;

SELECT sessionproperty ('QUOTED_IDENTIFIER');
```

Наиболее простым способом является использование динамически 
административного представления sys.dm_exec_session, поскольку оно позволяет 
получить значения всех параметров инструкции SET, используя только один запрос. 
(Опять же, если значение столбца равно 1, то соответствующий параметр активирован.) 
В примере ниже демонстрируется использование этой функции для получения 
значений первых четырех параметров инструкции SET:

```sql
USE SampleDb;

SELECT quoted_identifier, concat_null_yields_null, 
    ansi_nulls, ansi_padding
    FROM sys.dm_exec_sessions
    WHERE session_id = @@spid;
```

Узнать, материализовано ли представление, т.е. использует ли оно дисковое пространство или нет,
можно с помощью системной процедуры sp_spaceused. Результат выполнения запроса 
в примере ниже показывает, что представление view_enter_month использует
область памяти как для данных, так и для определенного индекса:

```sql
USE SampleDb;

EXEC sp_spaceused 'view_enter_month';
```

---

### Преимущества индексированных представлений

Кроме возможного повышения уровня производительности для сложных представлений, 
к которым часто обращаются запросы, применение индексированных представлений имеет два других преимущества:

* индекс представления может быть использован даже в том случае, если в представлении явно не указана ссылка на предложение FROM;
* все изменения данных отражаются в соответствующих индексированных представлениях.

Возможно, самой важной особенностью индексированных представлений является то,
что у запроса в представлении нет явного указания на использование индекса в этом представлении.
Иными словами, если запрос содержит ссылку на столбцы в базовой таблице (или таблицах),
которые также существуют в индексированных представлениях, и оптимизатор запросов определит,
что самым лучшим способом выполнения запроса будет использование индексированного представления, 
то он выбирает индексы представления таким образом, как и индексы таблиц, когда запрос не ссылается на них явно.

При создании индексированного представления его результирующий набор сохраняется на диске
(одновременно с созданием индекса). Таким образом, все данные, которые изменяются в базовых таблицах,
также изменяются в соответствующем результирующем наборе индексированного представления.

Кроме всех преимуществ, которые можно получить благодаря использованию индексированных представлений, 
имеется также и потенциальный недостаток: индексы индексированных представлений обычно более сложны в обслуживании, 
чем индексы базовых таблиц. Причиной этому является то, что структура однозначного кластеризованного
индекса индексированного представления более сложна, чем структура соответствующего индекса базовой таблицы.

Можно значительно повысить уровень производительности следующих далее запросов,
если проиндексировать представления, к которым они обращаются:

* запросы, которые обрабатывают большое количество строк и содержат операции соединения или агрегатные функции;
* операции соединения и агрегатные функции, которые часто выполняются в одном или нескольких запросах.

Если запрос ссылается на обычное представление, и системе баз данных требуется 
обработать большое количество строк, используя операцию соединения, то оптимизатор
обычно выбирает менее оптимальный метод соединения. Но если для этого представления определить кластеризованный индекс, 
то уровень производительности запроса можно значительно повысить,
т.к. оптимизатор запросов может использовать наиболее подходящий метод. 
(То же самое относится и к агрегатным функциям.)

Даже если запрос, который обращается к обычному представлению, и не обрабатывает 
большое количество строк, все равно, в случае частого использования такого запроса,
применение индексированного представления может быть очень полезным.
То же самое относится и к группе запросов, которые соединяют одни и те же таблицы или используют один и тот же тип агрегатных функций.

Начиная с версии SQL Server 2008 R2, Microsoft предоставляет альтернативное решение,
взамен индексированных представлений, которое называется фильтруемыми индексами. 
Фильтруемые индексы представляют собой особую форму некластеризованных индексов,
в которой индекс сужается, используя условие в конкретном запросе. 
Использование фильтруемых индексов имеет несколько преимуществ над использованием индексированных представлений.

