---
Инструкции OLAP: Лабораторная работа
---

[Таблица учеников](assets/lab5/Pupils.xlsx)

[К списку лабораторных >>>](../README.md)

---

### Задание по таблице учеников

1. Напишите запрос, который выводит максимальный балл учеников по школам,
   по каждому предмету по каждой школе и промежуточные итоги.
3. Напишите запрос, который выводит минимальный балл учеников по школам и по предметам, и промежуточные итоги.
4. Напишите запрос, который выводит средний балл учеников по школам и по предметам.
5. Напишите запрос, который выводит количество учеников по каждой школе по предметам и промежуточные итоги.
   NULL значения заменить на соответствующий текст.
6. Напишите запрос, который выводит суммарный балл учеников по школам и по предметам, и промежуточные итоги.
   В итоговых строках NULL значения заменить на соответствующий текст в зависимости от группировки.
8. Напишите запрос, который выводит максимальный балл учеников по школам и по предметам.
   В итоговых строках NULL значения заменить на соответствующий текст в зависимости от уровней группировки.
10. Напишите запрос, который выводит средний балл учеников по школам в столбцы.
11. Напишите запрос, который выводит средний балл учеников по школам в столбцы и по предметам в строки.
12. Напишите запрос, который выводит названия предметов, фамилии учеников и школы в один столбец.

---

### [Инструкции OLAP](https://metanit.com/sql/sqlserver/5.3.php)

Дополнительно к стандартным операторам GROUP BY и HAVING SQL Server поддерживает еще четыре специальных расширения для группировки данных: ROLLUP, CUBE, GROUPING SETS и OVER.

---

### ROLLUP

Operator ROLLUP создаёт группу для каждого сочетания выражений столбцов. 
Кроме того, выполняет сведение результатов в промежуточные и общие итоги, т.е. добавляет суммирующую строку в результирующий набор.
Для этого запрос перемещается справа налево, уменьшая количество выражений столбцов, по которым он создает группы и агрегаты. 

Синтаксис команды имеет следующий вид:
```sql
GROUP BY ROLLUP(<список столбцов>)
```
или
```sql
GROUP BY <список столбцов> WITH ROLLUP
```

Пример:
```sql
SELECT Manufacturer, COUNT(*) AS Models, SUM(ProductCount) AS Units
FROM Products
GROUP BY Manufacturer WITH ROLLUP
```

Альтернативный синтаксис запроса, который можно использовать, начиная с версии MS SQL Server 2008:

```sql
SELECT Manufacturer, COUNT(*) AS Models, SUM(ProductCount) AS Units
FROM Products
GROUP BY ROLLUP(Manufacturer)
```

При группировке по нескольким критериям ROLLUP будет создавать суммирующую строку для каждой из подгрупп:

```sql
SELECT Manufacturer, COUNT(*) AS Models, SUM(ProductCount) AS Units
FROM Products
GROUP BY Manufacturer, ProductCount WITH ROLLUP
```

Порядок столбцов влияет на выходные данные ROLLUP и может отразиться на количестве строк в результирующем наборе.

GROUP BY ROLLUP(col1, col2) создает группы для каждой комбинации выражений столбцов в следующих списках:
col1, col2
col1, NULL

NULL, NULL – это общий итог.

При сортировке с помощью ORDER BY следует учитывать, что она применяется уже после добавления суммирующей строки.

---

### CUBE

Оператор CUBE создает группы для всех возможных сочетаний столбцов. 
CUBE похож на ROLLUP за тем исключением, что CUBE добавляет суммирующие строки для каждой комбинации групп.

Синтаксис команды имеет следующий вид:

```sql
GROUP BY CUBE(<список столбцов>)
```
или
```sql
GROUP BY <список столбцов> WITH CUBE
```

GROUP BY CUBE(col1, col2) создает группы для каждой комбинации выражений столбцов в следующих списках:
col1, col2
col1, NULL
NULL, col2
NULL, NULL – это общий итог.

Пример: Напишите запрос, который выводит количество учеников по предметам и по школам, и промежуточные итоги:
```sql
SELECT Предмет, Школа
,COUNT(Фамилия) AS Количество
FROM
Ученики
GROUP BY
Предмет, Школа WITH CUBE
```

Пример: Напишите запрос, который выводит количество учеников по предметам и по школам, и промежуточные итоги. 
В итоговых строках NULL значения заменить на соответствующий текст в зависимости от группировки:
```sql
SELECT
IIF(GROUPING(Предмет)=1, 'ИТОГО', Предмет) AS Предмет
,IIF(GROUPING(Школа)=1, 'Итого', Школа) AS Школа
,COUNT(Фамилия) AS Количество
FROM
Ученики
GROUP BY
CUBE(Предмет, Школа)
```

---

### GROUPING SETS

Оператор GROUPING SETS позволяет объединять несколько предложений GROUP BY в одно предложение GROUP BY. 
Оператор GROUPING SETS аналогично ROLLUP и CUBE добавляет суммирующую строку для групп. Но при этом он не включает сами группам.
Результаты эквивалентны тем, что формируются с применением конструкции UNION ALL к указанным группам. 

Синтаксис команды имеет следующий вид:

```sql
GROUP BY GROUPING SETS(<список столбцов>)
```

Пример:
```sql
SELECT Manufacturer, COUNT(*) AS Models, ProductCount
FROM Products
GROUP BY GROUPING SETS(Manufacturer, ProductCount)
```

Если параметр GROUPING SETS имеет два или более элементов, результатом будет объединение элементов.
SQL не консолидирует повторяющиеся группы, созданные для списка GROUPING SETS.

GROUP BY GROUPING SETS(col1, col2) создает группы для каждой комбинации выражений столбцов в следующих списках:
col1, NULL
NULL, col2


С помощью скобок можно определить более сложные сценарии группировки:

```sql
SELECT Manufacturer, COUNT(*) AS Models, 
        ProductCount, SUM(ProductCount) AS Units
FROM Products
GROUP BY GROUPING SETS((Manufacturer, ProductCount), ProductCount)
```

Для предложения GROUP BY, использующего ROLLUP, CUBE или GROUPING SETS, допускается максимум 32 выражения.

Пример: Напишите запрос, который выводит количество учеников по предметам и по школам:
```sql
SELECT Предмет, Школа
,COUNT(Фамилия) AS Количество
FROM
Ученики
GROUP BY
GROUPING SETS(Предмет, Школа)
```

---

### GROUPING и GROUPING_ID

Функция GROUPING указывает, является ли указанное выражение столбца в списке GROUP BY статистическим или нет. 
В результирующем наборе возврат будет 1 (статистическое выражение) или ноль (нестатистическое выражение). 
Функция GROUPING может использоваться только в предложениях SELECT, HAVING и ORDER BY, если указано предложение GROUP BY.
Функция GROUPING_ID вычисляет уровень группирования. 
Функция GROUPING_ID может использоваться только в предложениях SELECT, HAVING и ORDER BY, если указано предложение GROUP BY.

---

### OVER

Выражение OVER позволяет суммировать данные, при этому возвращая те строки, которые использовались для получения суммированных данных. 
Например, найдем количество моделей и общее количество товаров этих моделей по производителю:

```sql
SELECT ProductName, Manufacturer, ProductCount,
        COUNT(*) OVER (PARTITION BY Manufacturer) AS Models,
        SUM(ProductCount) OVER (PARTITION BY Manufacturer) AS Units
FROM Products
```

Выражение OVER ставится после агрегатной функции, затем в скобках идет выражение PARTITION BY и столбец, 
по которому выполняется группировка.

То есть в данном случае мы выбираем название модели, производителя, количество единиц модели и 
добавляем к этому количество моделей для данного производителя и общее количество единиц всех моделей производителя.

---

### PIVOT

Оператор PIVOT поворачивает возвращающее табличное значение выражение, преобразуя уникальные значения одного столбца выражения в несколько выходных столбцов. В
случае необходимости PIVOT также объединяет оставшиеся повторяющиеся значения столбца и отображает их в выходных данных.
Синтаксис PIVOT является более простым и понятным, чем синтаксис, 
который может выполнить то же действие с помощью последовательности инструкций SELECT...CASE. 

Синтаксис имеет следующий вид:
```sql
SELECT < столбцы для группировки>, <пивотируемые столбцы >
FROM
(<запрос возвращающий данных>)
AS <псевдоним>
PIVOT
(<агрегирующая функция>(<столбец>)
FOR [<столбец, значения которого будут заголовками>]
IN (<список пивотируемых столбцов>)
) AS <псевдоним для пивот-таблицы>
```

Пример: Напишите запрос для вывода количества учеников для каждой школы по каждому предмету 
(школы должны быть указаны в строках, предметы в столбцах):
```sql
SELECT
Школа, Математика, Физика, Химия
FROM
(
SELECT
Школа, Предмет, Фамилия
FROM
Ученики
) AS SOURCE_TABLE
PIVOT
(
COUNT(Фамилия)
FOR Предмет IN (Математика, Физика, Химия)
) AS PIVOT_TABLE
```

---

### UNPIVOT

Оператор UNPIVOT поворачивает возвращающее табличное значение выражения, преобразуя нескольких выходных столбцов в один столбец. 

Синтаксис имеет следующий вид:
```sql
SELECT <список столбцов>
FROM
<таблица>
UNPIVOT
(<столбец значения строк> FOR [<столбец, значения заголовок>]
IN (<список анпивотируемых столбцов>)
) AS <псевдоним для анпивот-таблицы>
```

---

